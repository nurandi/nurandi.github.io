[{"content":"Sejak beralih dari Wordpress ke Jekyll dan GitHub beberapa tahun terakhir, alur untuk penulisan dan penerbitan artikel biasanya: menulis file markdown di Notepad/Notepad++ → jekyll serve untuk generate blog sehingga bisa dilakukan pratinjau → jika sudah sesuai, git push ke GitHub untuk menerbitkan artikel. Tidak ada yang salah dengan workflow seperti ini. Hanya saja, saya sedikit \u0026ldquo;kerepotan\u0026rdquo; karena ada beberapa aplikasi yang harus saya buka secara bergantian, yaitu:\nNotepad/Notepad++ untuk menulis artikel dalam format markdown. Untuk artikel berisi koding R, saya juga menulis kode di RStudio, menjalankannya, lalu copy-paste kode dan outputnya ke dalam file markdown yang sedang saya tulis; Bash/Ubuntu for Windows untuk menjalankan Jekyll; dan Git Bash untuk push artikel ke GitHub. Saya merasa proses tersebut bisa disederhanakan.\nBeruntung saya menemukan blog David Robinson. Ia tidak menulis artikel pada file *.md, melainkan pada file RMarkdown *.Rmd. File-file markdown sebagai \u0026ldquo;core\u0026rdquo; dari Jekyll, ia generate dengan knitr \u0026ndash; salah satu fungsi di R. Dengan cara ini, kita bisa fokus membuat artikel, file *.Rmd, di RStudio. Pratinjau artikel bisa dilakukan dengan klik icon Knit to HTML di RStudio. Untuk push ke GitHub, kita bisa integrasikan Git Bash dengan RStudio terminal. Secara ringkas, alurnya dapat digambarkan:\nMari kita lihat detailnya satu per satu.\n1. Tulis artikel dalam format RMarkdown *.Rmd di RStudio. Seluruh file RMarkdown saya simpan dalam satu folder tersendiri yaitu _Rmd. Jangan lupa untuk menuliskan YAML sebagaimana kita menuliskannya dalam file *.md. Apabila ingin melakukan pratinjau, klik ikon Knit lalu Knit to HTML. Meskipun HTML ini tidak mengunakan layout Jekyll, pratinjau ini bermanfaat untuk memeriksa penulisan.\n{% include image url=\u0026quot;/img/blog/2019-12-08-kombinasi-apik-buat-blogging-rstudio-jekyll-github/rstudio.png\u0026quot; alt=\u0026ldquo;RStudio\u0026rdquo; caption=\u0026ldquo;RStudio\u0026rdquo; %}\nKelebihan menggunakan RMarkdown adalah jika dalam artikel kita terdapat kode R, maka kode dan outputnya dapat diatur apakah akan ditampilkan atau tidak. Sehingga tidak ada lagi proses copy-paste. Misalnya, flowchart di atas merupakan output dari kode R (yang disembunyikan).\n```{r, echo=FALSE}\rlibrary(DiagrammeR)\rDiagrammeR(\"\rgraph TB\rA(Tulis artikel .Rmd di RStudio)\r--\u003eB(Generate file .md dengan fungsi knitr)\rB--\u003eC(Opsional: Jekyll serve untuk pratinjau)\rC--\u003eD(git push untuk unggah ke GitHub)\rB--\u003eD\rstyle C fill:yellow\r\" )\r```\rContoh lain:\n{% highlight r %} summary(cars)\n{% endhighlight %}\n{% highlight text %}\nspeed dist Min. : 4.0 Min. : 2.00 1st Qu.:12.0 1st Qu.: 26.00 Median :15.0 Median : 36.00 Mean :15.4 Mean : 42.98 3rd Qu.:19.0 3rd Qu.: 56.00 Max. :25.0 Max. :120.00 {% endhighlight %}\natau gambar/plot\n{% highlight r %} plot(pressure)\n{% endhighlight %}\n2. Generate file *.md. Dengan menjalankan _scripts/knitpages.R melalui perintah Rscript _scripts/knitpage.R di RStudio terminal, file-file *.Rmd pada folder _Rmd akan di-knit ke dalam format *.md di folder _posts. (knitpage.R saya sadur dari github.com/dgrtwo dengan sedikit perubahan).\n3. (Opsional) Jekyll serve untuk meng-compile blog dan preview. Bisa dilakukan apabila PC sudah terinstal Jekyll. Sangat bermanfaat untuk melihat tampilan sebenarnya sebelum artikel diterbitkan secara online. Saya sendiri menginstal Jekyll di Ubuntu for Windows. Sayangnya untuk menjalankan kita harus \u0026ldquo;keluar\u0026rdquo; dulu dari RStudio, buka Ubuntu, lalu ketikan perintah bundle exec jekyll serve.\n4. Langkah terakhir adalah git push ke GitHub untuk menerbitkan artikel. Apabila di PC sudah terinstal Git Bash, kita dapat menjalankan perintah berikut pada RStudio terminal;\ngit add .\rgit commit -m \u0026#34;publish new article with image\u0026#34;\rgit push Sebenarnya, ada workflow yang lebih menarik untuk dicoba yaitu dengan menggunakan package blogdown. Sesuai dengan namanya, blogdown merupakan R package untuk membuat blog atau website dengan R. Menariknya, blogdown juga mendukung Jekyll. Hanya saja saya belum mencobanya. Mungkin nanti, kapan-kapan.\n","permalink":"/blog/kombinasi-apik-buat-blogging-rstudio-jekyll-github/","summary":"Sejak beralih dari Wordpress ke Jekyll dan GitHub beberapa tahun terakhir, alur untuk penulisan dan penerbitan artikel biasanya: menulis file markdown di Notepad/Notepad++ → jekyll serve untuk generate blog sehingga bisa dilakukan pratinjau → jika sudah sesuai, git push ke GitHub untuk menerbitkan artikel. Tidak ada yang salah dengan workflow seperti ini. Hanya saja, saya sedikit \u0026ldquo;kerepotan\u0026rdquo; karena ada beberapa aplikasi yang harus saya buka secara bergantian, yaitu:\nNotepad/Notepad++ untuk menulis artikel dalam format markdown.","title":"Kombinasi Apik buat Blogging: RStudio, Jekyll, GitHub"},{"content":"Sudah 2019. Artikel terakhir di blog ini ditulis pada 29 Desember 2017. Artinya, sepanjang 2018 tidak ada satupun artikel yang saya publish. :(\nKetika saya \u0026ldquo;berniat\u0026rdquo; menulis kembali beberapa hari yang lalu, saya baru menyadari bahwa laptop yang saya pakai saat ini ternyata belum terpasang \u0026ldquo;mesin\u0026rdquo; untuk menulis blog. Memang, sepanjang 2018, laptop sudah 2x berganti. Dulu saya menggunakan Wordpress, salah satu content management system (CMS) populer, untuk menulis blog. Belakangan, Wordpress berkembang tidak hanya sebagai \u0026ldquo;mesin\u0026rdquo; blog, tetapi juga dapat digunakan untuk membuat website portal, toko online, bahkan forum. Bagi saya - yang hanya memanfaatkannya untuk blog dan itu pun tidak rutin - Wordpress terlalu overkill alias berlebihan. Terlalu banyak fitur :D Karena itu, setelah menemukan artikel tentang Jekyll sekitar dua tahun lalu dan kemudian membandingkannya dengan Wordpress, saya mantap beralih untuk menjadikan Jekyll sebagai \u0026ldquo;mesin\u0026rdquo; di belakang blog saya.\nSekalian install Jekyll, saya tuliskan saja tahapannya. Lumayan, dapat satu artikel kan. Selain sebagai catatan saya, mudah-mudahan bisa bermanfaat ketika ada yang membutuhkan.\n{% include image url=\u0026quot;/img/blog/2019-01-06-apa-itu-jekyll-bagaimana-instalasinya-di-windows/logo-jekyll.jpg\u0026quot; alt=\u0026ldquo;Logo Jekyll\u0026rdquo; caption=\u0026ldquo;Logo Jekyll\u0026rdquo; %}\nApa itu Jekyll? Baik, saya mulai dengan perkenalan dulu. Apa itu Jekyll?\nKita tahu bahwa ada dua jenis website: dynamic dan static. Pada dinamic website - misalnya yang dibuat menggunakan CMS seperti Wordpress, Joomla, Drupal dan Blogger/Blogspot - informasi atau konten untuk mengisi sebuah halaman web disimpan dalam database yang kemudian akan ditarik ketika ada \u0026ldquo;perintah\u0026rdquo; atau query. Sebagai contoh, ketika kita akan melakukan pencarian produk di Tokopedia, halaman HTML utuh yang berisi hasil pencarian sebenarnya tidak ada. Tetapi Tokopedia mempunyai template khusus untuk memuat hasil pencarian. Sistem akan melakukan query untuk mencari produk pada database sesuai kata kunci, selanjutnya daftar produk yang ditemukan akan dimuat dalam template tersebut.\nDi sisi lain, static website tidak menggunakan database. Seluruh informasi yang akan ditampilkan pada suatu halaman web memang sudah ada pada file HTML-nya. Tidak ada lagi proses query. File-file HTML ini dapat ditulis satu-persatu menggunakan text editor seperti Notepad atau Sublime Text, atau dapat pula dihasilkan secara otomatis menggunakan \u0026ldquo;static site generator\u0026rdquo; seperti Jekyll.\nJekyll, sesuai tagline-nya \u0026ldquo;a simple, blog-aware, static site generator\u0026rdquo; adalah software untuk membuat blog statis. Untuk menghasilkan sebuah blog, Jekyll hanya membutuhkan template, file-file artikel yang ditulis dengan format Markdown dan sebuah file konfigurasi. Kemudian hasilnya kita upload ke server. Itulah blog kita. Sesederhana itu. Mungkin terdengar seperti alternatif yang hanya cocok untuk para \u0026ldquo;geek\u0026rdquo;, tapi sebenernya Jekyll (dan juga static blog lainnya) mempunyai banyak kelebihan dibandingkan Wordpress dkk, di ataranya:\nSeperti yang sudah saya sampaikan, Wordpress itu overkill. Terlalu berlebihan, setidaknya untuk kebutuhan saya dalam membuat blog. Sementara itu, Jekyll memang dikhususkan sebagai blogging platform. Meskipun jauh lebih simple, Jekyll tetap kaya akan fitur-fitur yang dibutuhkan untuk membuat blog. Jekyll jauh lebih cepat. Itu karena semua halaman yang ditampilkan memang sudah benar-benar \u0026ldquo;jadi\u0026rdquo;. Tidak ada lagi query ke database. Selain itu, memuat file statis pada halaman website membutuhkan sumberdaya yang jauh lebih kecil di sisi server. Karena server hanya berisi file-file statis, Jekyll lebih aman dari \u0026ldquo;gangguan\u0026rdquo; hacker yang tidak bertanggungjawab. Tidak ada sesuatu yang bisa disasar oleh hacker, kecuali mereka punya username dan password-nya :D Bandingkan dengan website berbasis Wordpress yang mempunyai banyak \u0026ldquo;lubang\u0026rdquo; untuk dieksploitasi. Jekyll adalah \u0026ldquo;mesin\u0026rdquo; di belakang Github. Karenanya, dengan mudah kita bisa publish blog pada Github. Gratis. Dengan Github, setiap perubahan pada blog kita akan terekam, meskipun hanya merubah satu huruf. Ya, Github adalah salah satu layanan versioning control yang paling populer. Selain itu, dengan Github memudahkan kita untuk kolaborasi. Jekyll menggunakan Markdown. Artinya saya bisa membuat artikel yang berisi R scripts dengan R Markdown. Tidak ada yang sempurna. Jekyll pun punya kelemahan dibandingkan Wordpress, di antaranya:\nTidak bisa update blog secara live. Perubahan dilakukan secara \u0026ldquo;lokal\u0026rdquo;, baru kemudian blog kita generate ulang. Menulis artikel pada Jekyll artinya menulis sebuah file teks. Formating dilakukan dengan menggunakan \u0026ldquo;simbol-simbol\u0026rdquo; khusus. Bagi yang tidak terbiasa tentu akan terasa merepotkan. Bandingkan dengan Wordpress, menulis artikel dan format-nya (teks tebal dan miring, ukuran huruf, menyisipkan gambar) semudah membuat tulisan dengan Microsoft Word: apa yang kita lihat itulah yang akan kita dapat (what you see is what you get - WYSIWYG). Tidak seperti template Wordpress yang dapat diganti dengan \u0026ldquo;sekali\u0026rdquo; klik, mengubah template Jekyll relatif memerlukan \u0026ldquo;upaya ekstra\u0026rdquo;, tricky alias rumit :( Instalasi Jekyll pada Windows 10 Jekyll pada Windows memang tidak didukung secara resmi. Official-support hanya untuk Linux dan MacOS. Meskipun begitu, bukan berarti kita tidak bisa menginstal dan menjalankan Jekyll pada Windows. Saya berhasil menginstall Jekyll dengan memanfaatkan sumber utama dari sini dan sini plus beberapa upaya ekstra yang sumbernya lupa tidak saya catat. Ya, instalasi pada Windows memang tidak sesederhana pada Linux atau MacOS - yang hanya cukup dengan beberapa baris perintah (dan sambungan internet tentunya). Kabar baiknya, jika menggunakan Windows 10 (versi 1607 atau lebih baru), kita mempunyai opsi lain untuk menginjalankan Jekyll pada Windows dengan memanfaatkan Windows Subsystem for Linux (WSL). Sederhananya, WSL adalah Linux yang diinstal pada Windows. Inilah yang saya jabarkan sekarang: Menginstal dan menjalankan Jekyll pada Windows 10 dengan WSL. Ada dua tahapan:\nPertama, Instal Windows Subsystem for Linux pada Windows 10 Tahapannya:\nDari start menu, klik Settings\nKlik Update \u0026amp; Security\nKlik For Developer\nPada bagian \u0026ldquo;Use developer features\u0026rdquo;, pilih Developer Mode\nWindows akan menampikan konfirmasi untuk mengaktifkan developer mode. Klik Yes\nWindows akan menginstal komponen-komponen yang diperlukan. Setelah selesai lakukan restart/reboot PC\nMasuk ke Control Panel\nKlik Programs\nKlik Turn Windows features on or off\nCek Windows Subsystem for Linux (beta), lalu klik OK\nUpdate: Seluruh tahapan 1-10 di atas dapat dilakukan dengan menjalankan perintah berikut pada Windows PowerShell (jalankan sebagai Administrator):\nEnable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux Windows akan menginstal komponen-komponen yang diperlukan. Setelah selesai lakukan restart kembali.\nDari start menu, buka Command Prompt (dapat dilakukan dengan memasukan kata kunci \u0026ldquo;cmd\u0026rdquo;)\nPada Command Prompt, masukan perintah berikut lalu tekan tombol enter\nlxrun /install Ketikan y untuk melanjutkan. Tekan enter\nWindows akan mulai mengunduh komponen-komponen yang diperlukan dan kemudian melakukan instalasi Linux.\nMasukkan username\tlalu tekan enter\nMasukan password lalu tekan enter\nMasukan kembali password lalu tekan enter\nInstalasi Windows Subsystem for Linux selesai. Restart kembali PC\nKedua, Instal Jekyll pada Windows Subsystem for Linux Tahapannya:\nDari start menu, buka aplikasi Bash on Ubuntu on Windows\nAtau, bisa juga buka Command Prompt, lalu ketikan perintah berikut lalu enter\nbash Update Ubuntu dengan perintah berikut lalu enter\nsudo apt-get update -y \u0026amp;\u0026amp; sudo apt-get upgrade -y Masukkan password yang dibuat pada tahapan pertama poin 17. Tunggu hingga proses selesai.\nJekyll berjalan pada Ruby. Instal Ruby dengan perintah berikut\nsudo apt-get install -y build-essential ruby-full Update Ruby gem\nsudo gem update –system Instal Jekyll\nsudo gem install jekyll bundler Membuat blog pertama dengan Jekyll Setelah Jekyll sukses diinstal, saatnya kita membuat blog. Caranya sangat mudah. Masih menggunakan Bash on Ubuntu on Windows :\nMasuk ke direktori di mana file-file statis Jekyll akan dibuat. Misalnya saya akan menyimpannya pada folder D:\\Personal\\Blog, maka masukkan perintah\ncd /mnt/d/Personal/Blog Buat blog Jekyll baru, misalnya myblog\njekyll new myblog Jekyll akan menginisiasi blog baru. Tunggu sampai proses selesai.\nSilakan periksa folder D:\\Personal\\Blog, akan ada folder baru dengan nama myblog. Folder inilah yang berisi file-file statis yang diperluka oleh Jekyll untuk membentuk blog.\nPerintah jekyll new myblog menginisiasi blog baru dengan template default yaitu minima. Jika ingin menggunakan template lain, bisa download/clone dari Github atau download dari sumber lain seperti ini dan ini. Ganti semua file dan folder di dalam folder myblog dengan template yang diinginkan.\nMasuk ke folder myblog\ncd /myblog Generate blog dan jalankan di server lokal\nbundle exec jekyll serve Buka browser. Blog dapat diakses melalui alamat http://127.0.0.1:4000\nSelamat, blog statis pertama telah selesai dibuat dengan menggunakan Jekyll. Selanjutnya, kita perlu menyunting file konfigurasi _config.yml untuk mengubah judul, link, maupun catatan kaki (footer). Buka file _config.yml dengan text editor seperti Notepad.\nPerubahan file konfigurasi tidak langsung dieksekusi oleh. Silakan kembali ke Bash on Ubuntu on Windows, lalu stop Jekyll service dengan cara menekan tombol (keyboard) Ctrl+C, lalu jalankan kembali dengan perintah\nbundle exec jekyll serve Silakan refresh browser. Halaman muka blog akan berubah menjadi seperti ini\nSelain mengubah title, url dan description, banyak pengaturan yang bisa dilakukan melalui file _config.xml, misalnya menampilkan menu, mengaktifkan komentar dengan Disqus dan lain-lain. Selengkapnya bisa dipelajari di laman dokumentasi template yang digunakan.\nMudah bukan? Jika ada yang ingin didiskusikan, bisa tinggalkan pesan pada kolom komentar di bawah atau bisa hubungi saya melalui email nurandi.mail@gmail.com. Semoga bermanfaat :)\n","permalink":"/blog/apa-itu-jekyll-bagaimana-instalasinya-di-windows/","summary":"Sudah 2019. Artikel terakhir di blog ini ditulis pada 29 Desember 2017. Artinya, sepanjang 2018 tidak ada satupun artikel yang saya publish. :(\nKetika saya \u0026ldquo;berniat\u0026rdquo; menulis kembali beberapa hari yang lalu, saya baru menyadari bahwa laptop yang saya pakai saat ini ternyata belum terpasang \u0026ldquo;mesin\u0026rdquo; untuk menulis blog. Memang, sepanjang 2018, laptop sudah 2x berganti. Dulu saya menggunakan Wordpress, salah satu content management system (CMS) populer, untuk menulis blog. Belakangan, Wordpress berkembang tidak hanya sebagai \u0026ldquo;mesin\u0026rdquo; blog, tetapi juga dapat digunakan untuk membuat website portal, toko online, bahkan forum.","title":"Apa Itu Jekyll dan Bagaimana Cara Instalasinya di Windows?"},{"content":"Setelah beberapa kali mau daftar, tapi gak jadi, mau daftar lagi tapi cuman wacana, akhirnya kemarin (28/12), jam 9-11 pagi, saya benar-benar ambil sertifikasi Cloudera Certified Data Analyst (CCA159). Sekitar 40 menit setelahnya, saya dapat email dari Cloudera yang menyatakan saya lulus. Alhamdulillahirabbil alamin.\nMelalui email tersebut Cloudera tidak hanya menyampaikan bahwa saya lulus, tetapi juga keterangan untuk tiap-tiap soal: apakah benar atau salah. Jika salah, disebutkan juga alasannya. Diberitahukan juga bahwa saya akan mendapatkan sertifikat elektronik melalui email yang akan dikirimkan dalam waktu 2-3 hari kerja.\n{% include base_path %}\n{% capture fig_img %} ![Nur Andi Setiabudi - Cloudera Certified CCA Data Analyst]({{ base_path }}/img/blog/2017-12-29-pengalaman-sertifikasi-cloudera-cca-data-analyst/cca-data-analyst.png) {% endcapture %}\n{{ fig_img | markdownify | remove: \"\" | remove: \"\n\" }}\rYeay, sertifikat CCA Data Analyst, dikirimkan Cloudera dua hari setelah saya dinyatakan lulus. Vefifikasi: http://certification.cloudera.com/verify\rDi artikel ini saya coba share pengalaman seputar CCA Data Analyst yang saya ikuti kemarin itu. Mudah-mudahan bermanfaat.\nMengapa mengambil sertifikasi? Saya telah bekerja dengan Hadoop (Cloudera) sekitar tiga tahun dan lebih dari empat tahun terbiasa menggunakan SQL. Akan tetapi, tidak begitu banyak yang sudah saya eksplor, hanya fitur \u0026ldquo;itu-itu saja\u0026rdquo; yang saya gunakan. Ini menjadi alasan bagi saya untuk mempelajari lebih banyak lagi fungsionalitas Hadoop.\nAlasan jujurnya lainnya sederhana saja: karena di-support (baca: dibayarin) kantor. Hehe. Bagi saya sertifikasi Cloudera lumayan mahal, USD295 per sekali ujian. Dan tidak bisa refund kalau gagal. Sebenarnya, rencana awalnya mau ambil CCP Data Scientist (yang terdiri dari tiga ujian). Tetapi entah kenapa, sertifikasi tersebut sudah tidak ada lagi.\nBagaimana tesnya? Exam atau ujian CCA Data Analyst (dan sertifikasi Cloudera lainya) ini dilakukan secara online melalui examslocal.com. Karena itu, setelah registrasi di Cloudera, saya diminta untuk membuat akun di examslocal dan memilih sendiri waktu yang pas untuk tes. Jika memang waktu belum memungkinkan, jangan khawatir. Kita bisa mengatur waktu di examslocal hingga maksimal satu tahun sejak registrasi di Cloudera.\nUjian bisa dilakukan di mana saja, tapi harus ruangan private dan tertutup. Area publik seperti cafe tidak diperbolehkan. Sesaat sebelum ujian dimulai, selain diminta untuk menunjukkan kartu identitas (KTP, SIM atau paspor), saya juga diminta untuk mengarahkan kamera laptop ke seputar ruangan, ke meja, dan juga bawah meja. Di atas meja harus bersih, hanya ada laptop dan mouse. Sekedar kertas atau pernak-pernik diminta untuk dipindahkan.\nMeskipun online, kita tetap diawasi dengan cara screen sharing dan menyalakan kamera. Saya diminta untuk menjukkan Windows task manager dan menutup semua aplikasi selain browser Chrome. Seluruh komunikasi dengan \u0026ldquo;pengawas\u0026rdquo; ini dilakukan melalui chat.\nApa saja soalnya? CCA Data Analyst adalah performance based exam. Kita langsung membuat script dan query untuk menyelesaikan setiap permasalahan berdasarkan requirement yang ditentukan. Sama sekali tidak berupa pertanyaan dengan jawaban pilihan ganda atau essay. Meskipun namanya CCA Data Analyst, bukan analytical skill (statistics atau machine learning) yang diuji, tetapi lebih ke technical skill bagaimana membuat query untuk menghasilkan output yang diinginkan.\nExam environment menggunakan Ubuntu yang sudah terinstal Cloudera di dalamnya. Selain itu beberapa aplikasi desktop seperti Sublime Text, Python dan Eclipse juga disediakan, tapi hanya Sublime yang saya gunakan.\nBegitu tes dimulai, saya diberikan satu halaman web yang isinya antara lain: link ke pertanyaan, penjelasan singkat tentang konfigurasi Cloudera yang terinstall termasuk hostname, dan link ke beberapa dokumentasi (CDH, Hive, Sqoop, Impala dan lain-lain). Sebaiknya luangkan waktu untuk membaca sekilas halaman ini.\nSaya diberi sembilan soal (problem), terdiri dari\nMembuat tabel di metastore dari data berformat Avro, Konversi data HDFS dari text menjadi Parquet, Membuat View, Loading data dari MySQL ke HDFS, dan soal yang paling banyak adalah membuat query (join, union, transform kolom, sorting, simple regex) untuk menyelesaikan case tertentu. Bagi rekan-rekan yang sudah terbiasa dengan SQL, saya yakin ini sangat mudah. Sebenarnya cuma ada dua soal yang secara eksplisit diminta menggunakan Hive, sisanya boleh pakai apa saja (Hive, Impala, Pig atau yang lainnya). Saya sendiri menggunakan Hive, Impala dan Sqoop.\nSebagai gambaran bagaimana contoh soalnya, silakan simak video dari Clodera berikut (video resmi di upload di vimeo).\n{% include youtube.html id=\u0026ldquo;Bcl07KH1naA\u0026rdquo; %}\nYa, memang sesederhana itu. Saya sendiri berhasil menyelesaikan delapan soal dengan benar (Skor minimum untuk lulus adalah 70%). Satu yang tidak bisa saya selesaikan adalah membuat table dari data Avro. Sama sekali tidak punya pengalaman dan tidak mempelajari ini sebelumnya. Sebenarnya saya sudah berusaha mencari di dokumentasi, sayangnya waktu tidak cukup.\nBagaimana persiapan sebelum sertifikasi? Karena ini adalah performance-based (hand-on) exam, cara terbaik untuk persiapan ini adalah practice, practice and practice\u0026hellip; Saya beruntung karena sebelum mengambil sertifikasi sudah punya sedikit pengalaman dengan ekosistem Hadoop (terutama Hive dan Sqoop) dan juga SQL. Untuk pendalaman, saya latihan melalui Cloudera Data Analyst Training (lagi-lagi sponsored by kantor). Selama pendalaman ini, saya lebih fokus ke file format, mencoba berbagai fungsi di Hive/Impala, dan menulis sendiri kode huruf-demi-huruf (tanpa copy-paste, hehe).\nLast but not least Latihan sudah maksimal dan segala sesuatunya sudah dipersiapkan, tapi kadang ada hal tak terduga yang membuat rencana tidak berjalan. Berikut tips dari saya.\nKarena online, koneksi internet sangat penting. Remokendasinya memang \u0026ldquo;hanya\u0026rdquo; 5Mbps, tapi menggunakan koneksi dengan kecepatan yang lebih tinggi lebih baik. Saya yang pakai wifi 10Mbps merasa kurang nyaman; beberapa kali masih ada lag. Tidak ada salahnya juga mempersiapkan koneksi cadangan.\nTime management sangat penting. Kita hanya punya waktu 120 menit untuk menyelesaikan 8-12 soal. Kita tidak harus mengerjakan secara berurutan, jadi kerjakan yang mudah dulu.\nMulailah mencoba menggunakan Ubuntu dan juga Terminal-nya, termasuk short-cut untuk copy-paste. Saya biasanya menggunakan Windows dengan Putty atau XShell, kemarin merasa sangat kerepotan saat akan copy-paste.\nSebelum ujian, sesekali bukalah dokumentasi Cloudera, Hive, Sqoop, dan tools lain yang relevan. Ini akan sangat membantu ketika kita lupa nama fungsi atau kode tertentu. Saya sendiri hanya punya beberapa menit sebelum waktu berakhir untuk membuka dokumentasi. Dan itu tidak cukup.\nSaat ujian:\nSebelum membukan soal/problem, sempatkan untuk membaca halaman paling awal. Di sana mungkin ada informasi penting yang diperlukan untuk mengerjakan soal, seperti hostname, username dan juga password Baca teliti instruction, data description dan juga output requirements di setiap soal. Pastikan menjawab sesuai requirements yang diminta Jika waktu masih tersedia, coba review kembali jawaban-jawabannya. Dan sekali lagi, pastikan sesuai requirements ya. Oke. Semoga bermanfaat. Kalau ada yang ingin ditanyakan bisa melalui kolom komentar ya. Atau email ke nurandi.mail[at]gmail.com.\nGood luck !\n","permalink":"/blog/pengalaman-sertifikasi-cloudera-cca-data-analyst/","summary":"Setelah beberapa kali mau daftar, tapi gak jadi, mau daftar lagi tapi cuman wacana, akhirnya kemarin (28/12), jam 9-11 pagi, saya benar-benar ambil sertifikasi Cloudera Certified Data Analyst (CCA159). Sekitar 40 menit setelahnya, saya dapat email dari Cloudera yang menyatakan saya lulus. Alhamdulillahirabbil alamin.\nMelalui email tersebut Cloudera tidak hanya menyampaikan bahwa saya lulus, tetapi juga keterangan untuk tiap-tiap soal: apakah benar atau salah. Jika salah, disebutkan juga alasannya. Diberitahukan juga bahwa saya akan mendapatkan sertifikat elektronik melalui email yang akan dikirimkan dalam waktu 2-3 hari kerja.","title":"Pengalaman Sertifikasi Cloudera CCA Data Analyst"},{"content":"This is a \u0026ldquo;hello world\u0026rdquo; example website for the blogdown package. The theme was forked from @jrutheiser/hugo-lithium-theme and modified by Yihui Xie.\n","permalink":"/about/","summary":"This is a \u0026ldquo;hello world\u0026rdquo; example website for the blogdown package. The theme was forked from @jrutheiser/hugo-lithium-theme and modified by Yihui Xie.","title":"About"},{"content":"Beberapa waktu lalu ketika sedang mencari cara untuk membuat peta dengan R, Google menunjukkan satu package yang sangat menarik - leaflet. Package yang dikembangkan oleh RStudio ini merupakan interface untuk membuat peta dengan memanfaatkan Leaflet, salah satu JavaScript library untuk pemetaan yang sangat populer dan tentu saja open-source.\nBerbeda dengan package lain (seperti RgoogleMaps, ggmap dan maps) yang menghasilkan peta statis, leaflet memudahkan kita untuk membuat peta interaktif yang lebih hidup hanya dengan beberapa baris kode R, tanpa perlu mempunyai pengetahuan tentang JavaScript. Tertarik untuk mencoba? Inilah hasil \u0026ldquo;eksperimen\u0026rdquo; pertama saya dengan R dan leaflet.\nPersiapan Sebenarnya dengan R saja cukup, namun saya merekomendasikan RStudio. Instal package leaflet dari CRAN:\ninstall.packages(\u0026#34;leaflet\u0026#34;) Atau dari GitHub, untuk versi development\ndevtools::install_github(\u0026#34;rstudio/leaflet\u0026#34;) Lalu load ke dalam R session\nlibrary(leaflet) Menandai suatu titik koordinat OK! saatnya kita \u0026ldquo;bermain\u0026rdquo; dengan leaflet. Sebelum menggunakan data Twitter, mari kita mulai dengan menandai suatu titik koordinat pada peta dengan icon marker, misalnya untuk lokasi \u0026ldquo;Bundaran Hotel Indonesia\u0026rdquo; yang menurut Google Maps berada pada koordinat (-6.1949571, 106.8230631).\npoint \u0026lt;- \u0026#34;Bundaran Hotel Indonesia\u0026#34; latitude \u0026lt;- -6.1949571 longitude \u0026lt;- 106.8230631 map \u0026lt;- leaflet() %\u0026gt;% addTiles() %\u0026gt;% addMarkers(lng=longitude, lat=latitude, popup=point) map {% include iframe.html url=\u0026ldquo;http://rstudio-pubs-static.s3.amazonaws.com/557067_1b954d2a081e41c09cde4f3edb57eb21.html\u0026quot; %}\nPenjelasannya kurang lebih:\nleaflet() : menginisiasi leaflet workspace, seakan sebuah kanvas di mana peta akan digambar di atasnya. addTiles() : menambahkan peta dasar base-map (secara default menggunakan OpenStreetMap). addMarkers() : menandai titik koordinat (lng untuk longitude dan lat untuk latitude) dengan icon marker. Opsi popup berguna untuk nenampilkan teks jika icon di-klik. Kode di atas menggunakan pipe operator (%\u0026gt;%) dari package magrittr, yang ekuivalen dengan:\nmap \u0026lt;- leaflet() map \u0026lt;- addTiles(map) map \u0026lt;- addMarkers(map, lng=longitude, lat=latitude, popup=point) map Memetakan data Twitter Kenapa data Twitter? Beberapa kali saya men-download data Twitter melalui search API baik menggunakan package twitteR maupun tools lain. Salah satu hal menarik mengenai tweet-tweet tersebut adalah adanya geo-coordinate, titik latitude dan longitute, yang menandai lokasi di mana mereka di-posting. Memang, informasi ini tidak tersedia untuk semua tweets, tapi cukup kaya untuk dieksplorasi seperti yang akan kita lakukan sekarang.\nDimulai dengan men-download tweets berdasarkan kata kunci tertentu menggunakan twitteR :\nlibrary(twitteR) setup_twitter_oauth(consumer_key = \u0026#34;XXX\u0026#34;, consumer_secret = \u0026#34;XXX\u0026#34;, access_token = \u0026#34;XXX\u0026#34;, access_secret = \u0026#34;XXX\u0026#34;) tweetsList \u0026lt;- searchTwitteR(\u0026#34;makan siang\u0026#34;, geocode = paste(latitude, longitude, \u0026#34;20km\u0026#34;, sep = \u0026#34;,\u0026#34;), n = 1000) Dengan fungsi di atas, kita berhasil mendapatkan 600-an tweets dengan kata kunci \u0026ldquo;makan siang\u0026rdquo; yang berada dalam radius 10km seputar Bundaran Hotel Indonesia, Jakarta.\nKonversi tweetList menjadi data frame:\ntweets \u0026lt;- twListToDF(tweetsList) Sebaiknya titik koordinat merupakan kolom numerik dan tidak ada data yang latitude/longitude-nya kosong (NA atau NULL).\ntweets$latitude \u0026lt;- as.numeric(tweets$latitude) tweets$longitude \u0026lt;- as.numeric(tweets$longitude) tweets \u0026lt;- tweets[!is.na(tweets$latitude) \u0026amp; !is.na(tweets$longitude),] Sekarang kita siap untuk mapping titik-titik koordinat data Twitter tersebut dengan leaflet:\ntweetsmap \u0026lt;- leaflet(data = tweets) %\u0026gt;% addTiles() %\u0026gt;% addMarkers(lng = ~longitude, lat = ~latitude, popup = ~screenName) tweetsmap {% include iframe.html url=\u0026ldquo;http://rstudio-pubs-static.s3.amazonaws.com/557075_7c48a041dab24dcda637d65e1b980801.html\u0026quot; %}\n(Hanya 100 twit pertama yg ditampilkan agar loading tidak terlalu lama)\nNice! Seluruh titik koordinat sudah kita tampilkan dalam peta hanya dengan empat baris kode R. Mudah, bukan?\nTentu saja kita bisa membuat tampilan peta tersebut menjadi lebih baik. Misalnya, ada dua hal sederhana yang saya lakukan dalam \u0026ldquo;eksperimen\u0026rdquo; ini. Pertama, menjadikan teks pada popup sebagai link untuk membuka tweets pada laman Twitter dengan cara mengubahnya menjadi konten HTML dengan format:\n\u0026quot;\u0026lt;a href=\u0026quot;https://twitter.com/SCREENNAME/status/STATUSID\u0026quot; target=\u0026quot;_blank\u0026quot;\u0026gt;SCREENNAME\u0026lt;/a\u0026gt;\u0026quot;\rBerikut ini perintah untuk membuat konten HTML tersebut:\nlink2tweet \u0026lt;- paste(\u0026#34;https://twitter.com\u0026#34;, tweets$screenName, \u0026#34;status\u0026#34;, tweets$id, sep = \u0026#34;/\u0026#34;) popupLink \u0026lt;- paste0(\u0026#34;\u0026lt;a href=\\\u0026#34;\u0026#34;, link2tweet, \u0026#34;\\\u0026#34; target=\\\u0026#34;_blank\\\u0026#34;\u0026gt;\u0026#34;, tweets$screenName, \u0026#34;\u0026lt;/a\u0026gt;\u0026#34;) Kedua, membuat marker cluster sehingga titik-titik pada peta tidak terlalu padat. Marker cluster mengelompokkan beberapa titik yang berdekatan dalam cluster dan menampilkan kembali seluruh titik apabila peta diperbesar (zoom-in). Untuk membuat marker cluster pada peta baru kita buat tadi bisa dilakukan dengan terlebih dahulu menghapus markers menggunakan fungsi clearMarkers(), lalu buat kembali dengan fungsi addMarkers() yang ditambahkan dengan opsi markerClusterOptions().\ntweetsmap \u0026lt;- clearMarkers(tweetsmap) %\u0026gt;% addMarkers(popup = popupLink, clusterOptions = markerClusterOptions()) tweetsmap Note: Jika latitude dan longitude tidak dinyatakan secara eksplisit, addMarker() akan mencari kolom lat/latitude dan lon/lng/long/longitude (case-sensitive) pada data-frame.\nIni adalah hasil akhir yang kita peroleh. Klik pada titik cluster untuk memperbesar peta!\n{% include iframe.html url=\u0026ldquo;http://rstudio-pubs-static.s3.amazonaws.com/557072_f157a8eea78d498299399ad13db43164.html\u0026quot; %}\nKurang canggih? Masih ada fitur-fitur leaflet yang lain untuk kita eksplorasi seperti mengganti map tiles, modifikasi markers dan pop ups, menambahkan polygons dan lines, dan banyak lagi.\n","permalink":"/blog/membuat-peta-dengan-r-dan-leaflet/","summary":"Beberapa waktu lalu ketika sedang mencari cara untuk membuat peta dengan R, Google menunjukkan satu package yang sangat menarik - leaflet. Package yang dikembangkan oleh RStudio ini merupakan interface untuk membuat peta dengan memanfaatkan Leaflet, salah satu JavaScript library untuk pemetaan yang sangat populer dan tentu saja open-source.\nBerbeda dengan package lain (seperti RgoogleMaps, ggmap dan maps) yang menghasilkan peta statis, leaflet memudahkan kita untuk membuat peta interaktif yang lebih hidup hanya dengan beberapa baris kode R, tanpa perlu mempunyai pengetahuan tentang JavaScript.","title":"Membuat Peta dengan R dan Leaflet: Contoh Data Twitter"},{"content":"Twitter menerapkan OAuth (saat ini OAuth 1.0a) dalam penyediaan akses ke API-nya. OAuth adalah sebuah authorization framework yang memungkinkan aplikasi pihak ketiga untuk mendapatkan akses terbatas secara aman dan ringkas. Dengan OAuth, untuk melakukan request ke API Twitter, setiap aplikasi harus terlebih dahulu mendapatkan OAuth access token. Access token ini yang kemudian digunakan untuk membuat \u0026ldquo;permintaan resmi\u0026rdquo; ke API Twitter, baik REST maupun Streaming.\nPada R, Twitter authentication dapat dilakukan dengan mudah dengan menggunakan fungsi setup_twitter_oauth() yang tersedia pada package twitteR seperti telah kita diskusikan pada artikel sebelumnya. Pada kesempatan ini, saya lebih tertarik untuk membahas proses autentikasi secara \u0026ldquo;semi-manual\u0026rdquo; dengan menggunakan package ROAuth dan httr. Mmmm\u0026hellip; Ternyata masih seputar API Twitter, semoga tidak membosankan :)\nROAuth dan httr ROAuth (ditulis oleh Jeff Gentry) merupakan interface untuk melakukan autentikasi ke server yang menerapkan OAuth. ROAuth menangani proses handshakes dan men-generate signatures. Sedangkan httr (ditulis oleh Hadley Wickham) merupakan interface ke web API yang telah support OAuth 1.0 dan 2.0. Kedua package tersebut akan kita gunakan untuk membuat authenticated requests, sehingga akses ke API Twitter dapat dilakukan melalui R console.\nTwitter authentication menggunakan ROAuth dan httr Proses autentikasi Twitter dengan menggunakan ROAuth dan httr dapat dilakukan dengan tahapan sebagai berikut.\nInstall package Bisa dari CRAN:\ninstall.packages(c(\u0026#34;ROAuth\u0026#34;, \u0026#34;httr\u0026#34;) Atau dari Github untuk versi development-nya\nlibrary(devtools) install_github(c(\u0026#34;geoffjentry/ROAuth\u0026#34;, \u0026#34;hadley/httr\u0026#34;) Generate access token Setiap request ke API Twitter membutuhkan \u0026ldquo;sepaket\u0026rdquo; credentials yang terdiri dari consumer key (API key), consumer secret (API secret), serta access token dan access token secret. Credentials tersebut bisa dipoleh dengan cara mendaftarkan sebuah aplikasi melalui apps.twitter.com. Pastikan Callback URL pada Application Management - Settings dikosongkan. Setelah mendaftarkan aplikasi, buka tab Keys and Access Tokens - di sana dapat kita temukan credentials yang diperlukan untuk autentikasi.\nHanya tersedia consumer key dan consumer secret ketika aplikasi baru dibuat. Untuk mendapatkan access token dan access token secret, klik tombol Create my access token. Sekarang, kembali ke R dan simpan key dan token tersebut. Misalnya:\nconsumerKey \u0026lt;- \u0026#34;XXX\u0026#34; consumerSecret \u0026lt;- \u0026#34;XXX\u0026#34; accessToken \u0026lt;- \u0026#34;XXX\u0026#34; accessTokenSecret \u0026lt;- \u0026#34;XXX\u0026#34; Selain di-copy-paste dari Aplication Management, access token dan access token secret juga dapat di-generate oleh R menggunakan package ROAuth.\nlibrary(ROAuth) consumerKey \u0026lt;- \u0026#34;XXX\u0026#34; consumerSecret \u0026lt;- \u0026#34;XXX\u0026#34; requestURL \u0026lt;- \u0026#34;https://api.twitter.com/oauth/request_token\u0026#34; authURL \u0026lt;- \u0026#34;https://api.twitter.com/oauth/authorize\u0026#34; accessURL \u0026lt;- \u0026#34;https://api.twitter.com/oauth/access_token\u0026#34; creds \u0026lt;- OAuthFactory$new(consumerKey = consumerKey, consumerSecret = consumerSecret, requestURL = requestURL, accessURL = accessURL, authURL = authURL) creds$handshake() Begitu script di atas dijalankan, proses handshaking dimulai. R akan memberikan link (URL) yang harus kita buka melalui browser (biasanya browser akan membuka link tersebut secara otomatis).\nTo enable the connection, please direct your web browser to: https://api.twitter.com/oauth/authorize?oauth_token=JFvu2AAAAAAAkQ9EAXXXXXXX\rWhen complete, record the PIN given to you and provide it here: Browser akan menampilkan laman di mana kita diminta untuk memberikan \u0026ldquo;izin\u0026rdquo; kepada aplikasi.\n![Authorise app]({{ site.url }}{{ site.baseurl }}/img/blog/2016-02-08-twitter-authentication-dengan-roauth-dan-httr/twitter-auth-token1.png)\nKlik \u0026ldquo;Authorize app\u0026rdquo;, Twitter akan menampilkan sebuah PIN.\n![Enter PIN]({{ site.url }}{{ site.baseurl }}/img/blog/2016-02-08-twitter-authentication-dengan-roauth-dan-httr/twitter-auth-token2.png)\nCopy-paste PIN tersebut ke R console, dan tekan enter - access token berhasil kita generate. Jika terjadi error\nError in function (type, msg, asError = TRUE) : SSL certificate problem: unable to get local issuer certificate\rinstal package RCurl, lalu tambahkan parameter pada creds$handshake() sehingga menjadi\ncreds$handshake(cainfo = system.file(\u0026#34;CurlSSL\u0026#34;, \u0026#34;cacert.pem\u0026#34;, package = \u0026#34;RCurl\u0026#34;)) Seluruh credentials telah disimpan pada objek creds. Selanjutnya, ekstrak access token:\naccessToken \u0026lt;- creds$oauthKey accessTokenSecret \u0026lt;- creds$oauthSecret Twitter token Setelah mendapatkan consumer key dan access token, inilah saatnya kita membuat Twitter token yang mengemas semua data yang dipersyaratkan untuk OAuth access, meliputi credentials dan berbagai parameters. Untuk tujuan ini kita gunakan package httr:\nlibrary(httr) app \u0026lt;- oauth_app(\u0026#34;twitter\u0026#34;, key = consumerKey, secret = consumerSecret) twitter_token \u0026lt;- Token1.0$new(endpoint = NULL, params = list(as_header = TRUE), app = app, credentials = list(oauth_token = accessToken, oauth_token_secret = accessTokenSecret)) DONE! Proses autentikasi selesai. Sekarang kita dapat men-download data Twitter, baik melalui REST API maupun Streaming API.\nDownload data Twitter Twitter menyediakan banyak sekali API - terutama REST API - misalnya search tweets untuk mencari tweet berdasarkan kata kunci tertentu, statuses user timeline untuk mendapatkan tweet terakhir yang diposting oleh user tertentu, atau followers ids untuk mendapatkan daftar ID follower dari user tertentu. Kita dapat menggunakan fungsi GET pada package httr untuk mendapatkan data twitter melalui APIs tersebut.\nSaya membuat fungsi sederhana untuk mencari tweet berdasarkan kata kunci (keyword) tertentu :\nsearch_twitter \u0026lt;- function(keyword, token) { require(httr) baseurl \u0026lt;- \u0026#34;https://api.twitter.com/1.1/search/tweets.json?q=\u0026#34; url \u0026lt;- paste0(baseurl, URLencode(keyword)) response \u0026lt;- GET(url, config(token = token)) content \u0026lt;- content(response)[[1]] text \u0026lt;- unlist(sapply(content,function(x) x$text)) return(text) } Misalnya, kita akan mencari tweet dengan kata kunci \u0026ldquo;angkot bogor\u0026rdquo;:\nangkot_bogor \u0026lt;- search_twitter(\u0026quot;angkot bogor\u0026quot;, token = twitter_token)\rHasilnya:\nangkot_bogor # [1] \u0026#34;Program One Way di Kota Bogor Terbentur Rute Angkot - Pojok Jabar https://t.co/hD7nkjjlHt #Bogor\u0026#34; # [2] \u0026#34;Catatan kecil kehidupan di hari ini... maaf cuma iseng... \\nUdah lama ga jalan2 ke bogor, liat angkot masih… — https://t.co/VsaBjUaIkc\u0026#34; # [3] \u0026#34;Program One Way di Kota Bogor Terbentur Rute Angkot - Pojok Jabar https://t.co/txYWQ8kzkm #Bogor\u0026#34; # [4] \u0026#34;Program One Way di Kota Bogor Terbentur Rute Angkot - Pojok Jabar https://t.co/dMSyKnnhMg #Bogor\u0026#34; # [5] \u0026#34;Program One Way di Kota Bogor Terbentur Rute Angkot - Pojok Jabar https://t.co/8ZK3yCY1Zy #Bogor\u0026#34; # [6] \u0026#34;RT @NyunyuCom: Kalo di Bogor, jangan sampe salah milih angkot! Biar kalo mau kemana-mana cepet, pilih angkot yg kayak gini gaes! https://t.…\u0026#34; # [7] \u0026#34;Kalo di Bogor, jangan sampe salah milih angkot! Biar kalo mau kemana-mana cepet, pilih angkot yg kayak gini gaes! https://t.co/hlA0tsDTSp\u0026#34; # [8] \u0026#34;Kota hujan. Kota sejuta angkot. \\xf0\\u009f\\u009a\\u0098\\u26c5\\u2614\\xf0\\u009f\\u008c\\u009e @ Patung Kujang Bogor https://t.co/xZiOvisWvv\u0026#34; # [9] \u0026#34;BOCORE - Angkot Bogor - Rp 70.000,- (S/M/L/XL/XXL) SMS/Telp : 081574232423 https://t.co/VRykHK1EkK https://t.co/GmoXJ9n4Zt #kaos #bogor\u0026#34; # [10] \u0026#34;Program One Way di Kota Bogor Terbentur Rute Angkot - Pojok Jabar https://t.co/UGxAD9PaUU #Bogor\u0026#34; # [11] \u0026#34;Move movee.....to second place we go....ujan2an di Bogor.....ihiiiyyyy...… (at Angkot 02 Cisarua Sukasari) — https://t.co/CANS9sTLlq\u0026#34; # [12] \u0026#34;RT @BogorSelatan_: Program One Way di Kota Bogor Terbentur Rute Angkot - Pojok Jabar https://t.co/Ac5J52xA7I #trafjak\u0026#34; # [13] \u0026#34;pasar ciawi tetep pasar tumpah dan tempat ngetem angkot depan pasar macet hallloooo wakikota Bogor ,,, mana bukti nya ????\u0026#34; # [14] \u0026#34;Program One Way di Kota Bogor Terbentur Rute Angkot - Pojok Jabar https://t.co/mBMZXt5jXA #Bogor #Jabar\u0026#34; # [15] \u0026#34;Program One Way di Kota Bogor Terbentur Rute Angkot - Pojok Jabar https://t.co/H5M8UuVyJ9 #Bogor\u0026#34; [UPDATE#1:] Sebelumnya telah dibahas bahwa dalam proses autentikasi Twitter menggunakan httr::Token1.0 diperlukan consumer key dan access token. Access token dapat diperoleh baik dari laman applications management maupun dengan cara handshaking menggunakan ROAuth::OAuthFactory. Kabar baiknya, dengan hanya berbekal consumer key dan consumer secret, kita sebenarnya bisa langsung melakukan autentikasi (generate Twitter token) menggunakan fungsi httr::oauth1.0_token.\nlibrary(httr) app \u0026lt;- oauth_app(\u0026#34;twitter\u0026#34;, key = consumerKey, secret = consumerSecret) twitter_token \u0026lt;- oauth1.0_token(oauth_endpoints(\u0026#34;twitter\u0026#34;), app = app) R console akan menampilkan pesan berikut:\nWaiting for authentication in browser...\rPress Esc/Ctrl + C to abort\rAuthentication complete.\rDengan fungsi ini, proses autentikasi dilakukan dalam browser dan kita tidak perlu memasukkan PIN. Biarkan R bekerja dan tunggu beberapa detik sampai proses autentikasi selesai. Agar autentikasi berhasil, Callback URL wajib diisi dengan http://127.0.0.1:1410.\nDengan demikian, setidaknya ada tiga alternatif yang bisa digunakan dalam proses autentikasi seperti yang tampilkan dalam flow-char berikut.\n![Twitter OAuth flowchar]({{ site.url }}{{ site.baseurl }}/img/blog/2016-02-08-twitter-authentication-dengan-roauth-dan-httr/twitter-auth-flowchart.png)\n[UPDATE#2:] Twitter token yang di-generate baik oleh httr::Token1.0 maupun httr::oauth1.0_token dapat digunakan sebagai pengganti fungsi setup_twitter_oauth() pada package twitteR.\nassign(\u0026#34;oauth_token\u0026#34;, twitter_token) library(twitteR) tweets \u0026lt;- searchTwitter(\u0026#34;indonesia raya\u0026#34;) sapply(head(tweets), statusText) # [1] \u0026#34;Roy suryo iki kritik menpora saiki, koyo pener wae leh mu jabat ndan. Ngapalke indonesia raya sik wae :)))\u0026#34; # [2] \u0026#34;Waduh bapak menpora ga pernah ikut upacara nih jadi ga hafal INDONESIA RAYA :(\u0026#34; # [3] \u0026#34;Alhamdulillah, hari ini panen raya padi sehat di sawah Daqu Sehat Indonesia, Sukabumi. Seluruh https://t.co/4kbWuBGC65\u0026#34; # [4] \u0026#34;RT @wawaraji: Sharing dg @basuki_btp gerakan @qluesmartcity #BERANIBERUBAH bersama @indorunners diawali nyanyikan Indonesia Raya https://t.…\u0026#34; # [5] \u0026#34;ماشاءالله تبارك الله \\n\\nRio Haryanto Menggegerkan Austria GP2 Series 2015 Juara dan Indonesia Raya Berkumandang,... https://t.co/aUPzxewj4A\u0026#34; # [6] \u0026#34;@UnsoedOfficial Apa Curug Favorit Netizen Banyumas Raya? https://t.co/A0O8JF2l2m #PollingTIN via @Times_indonesia\u0026#34; Selamat mencoba, semoga bermanfaat :)\nCredits: smappR by SMaPP at New York University streamR by Pablo Barberá ROAuth by Jeff Gentry httr by Hadley Wickham ","permalink":"/blog/twitter-authentication-dengan-roauth-dan-httr/","summary":"Twitter menerapkan OAuth (saat ini OAuth 1.0a) dalam penyediaan akses ke API-nya. OAuth adalah sebuah authorization framework yang memungkinkan aplikasi pihak ketiga untuk mendapatkan akses terbatas secara aman dan ringkas. Dengan OAuth, untuk melakukan request ke API Twitter, setiap aplikasi harus terlebih dahulu mendapatkan OAuth access token. Access token ini yang kemudian digunakan untuk membuat \u0026ldquo;permintaan resmi\u0026rdquo; ke API Twitter, baik REST maupun Streaming.\nPada R, Twitter authentication dapat dilakukan dengan mudah dengan menggunakan fungsi setup_twitter_oauth() yang tersedia pada package twitteR seperti telah kita diskusikan pada artikel sebelumnya.","title":"Twitter Authentication dengan ROAuth dan httr"},{"content":"Beberapa waktu lalu, sesaat setelah mengganti theme blog ini dari TwentyFifteen menjadi Designer, saya mencari syntax highlighter untuk mempercantik (prettify) tampilan kode yang saya posting di sini. Dari hasil pencarian dengan Google, ada banyak yang bisa dipasang pada Wordpress. Namun, saya lebih tertarik untuk menggunakan prism.js. Alasannya sederhana: kombinasi warnanya yang saya rasa cocok dengan theme secara keseluruhan, ukuran file javascript maupun css yang sangat kecil sehingga waktu loading sangat cepat, mudah cara memasang dan menggunakannya, dan yang terpenting, prism.js mendukung banyak bahasa pemprograman termasuk R.\n![Prism.js]({{ site.url }}{{ site.baseurl }}/img/blog/2016-01-31-syntax-highlighter-dengan-prism-js-pada-wordpress/prism-js.png)\nPada kesempatan kali ini, saya akan jelaskan langkah mudah untuk memasang syntax highlighter dengan prism.js pada Wordpress, yang sebagaian besar saya adopsi dari How To Implement Prism.js Syntax Highlighting Into Your WordPress Site.\nDownload Prism.js Langkah pertama adalah kunjungi laman donwload Prism.js. Di laman ini ada beberapa opsi yang bisa kita pilih, yaitu:\nPada bagian Compression level, pilih Minified version. Pilih theme. Blog ini menggunakan theme default, namun kita juga dapat memilih theme lain yaitu dark, funky, okaidia, twilight, coy dan solarized light. Pilih bahasa pemprograman. Saya memilih beberapa bahasa pemrograman untuk analisis data seperti R, SAS, Python dan SQL. Kita bisa memilih sebanyak mungkin bahasa atau bahkan semua bahasa pemrograman, namun semakin banyak yang dipilih maka file javascript dan css pun akan semakin besar. Kita juga dapat memilih Plugin yang menawarkan fungsi-fungsi tambahan seperti untuk penomoran baris, highlight baris tertentu dan lain-lain. Saya tidak menggunakan plugin apapun untuk blog ini. Selanjutnya, klik \u0026ldquo;DOWNLOAD JS\u0026rdquo; sebagai \u0026ldquo;prism.js\u0026rdquo; dan \u0026ldquo;DOWNLOAD CSS\u0026rdquo; sebagai \u0026ldquo;prism.css\u0026rdquo;. Tentu saja kita bisa menggunakan penamaan lain untuk file javascript dan css ini. Upload Prism.js Langkah selanjutnya adalah upload kedua file di atas (prism.js dan prism.css) ke folder theme Wordpress (wp-content/themes/\u0026lt;theme yang digunakan\u0026gt;), melalui File Manager pada CPanel atau dengan menggunakan FTP client. Saya menggunakan theme \u0026ldquo;Designer-child\u0026rdquo;, sehingga file prism.js dan prism.css di-upload ke wp-content/themes/designer-child. Atau, bisa juga upload kedua file tersebut folder khusus, misalnya wp-content/themes/designer-child/prism.\nBuat function pada functions.php Sisipkan kode berikut pada file functions.php\n\u0026lt;?php function add_prism() { wp_register_style( \u0026#39;prismCSS\u0026#39;, get_stylesheet_directory_uri() . \u0026#39;/prism.css\u0026#39; ); wp_register_script( \u0026#39;prismJS\u0026#39;, get_stylesheet_directory_uri() . \u0026#39;/prism.js\u0026#39; ); wp_enqueue_style(\u0026#39;prismCSS\u0026#39;); wp_enqueue_script(\u0026#39;prismJS\u0026#39;); } add_action(\u0026#39;wp_enqueue_scripts\u0026#39;, \u0026#39;add_prism\u0026#39;); ?\u0026gt; Note: Saya menyimpan file prism.css dan prism.js pada folder \u0026ldquo;prism\u0026rdquo;, sehingga saya harus sedikit memodifikasi function di atas tengan menguaba directory '/prism.css' menjadi '/prism/prism.css' dan '/prism.js' menjadi '/prism/prism.js'\nMenulis kode dengan Prism.js Untuk menulis kode pada artikel (post/page), caranya adalah menggunakan tag \u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt; dengan class language-markup. Ganti \u0026ldquo;markup\u0026rdquo; dengan bahasa yang sesuai. Misalnya, saya menuliskan kode SQL, maka untuk menggunakan syntax highlighter :\n\u0026lt;pre\u0026gt;\u0026lt;code class=\u0026#34;language-sql\u0026#34;\u0026gt; SELECT * , SUM(Qty) OVER() Sum_qty FROM Orders; \u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt; Atau, jika Wordpress kita sudah support Markdown, maka cukup tuliskan:\n```.language-sql\rSELECT *\r, SUM(Qty) OVER() Sum_qty FROM Orders;\r```\rKeduannya akan menghasilkan\n![Prism.js]({{ site.url }}{{ site.baseurl }}/img/blog/2016-01-31-syntax-highlighter-dengan-prism-js-pada-wordpress/prism-js-demo.png)\nMudah bukan? Selamat mencoba :)\n","permalink":"/blog/syntax-highlighter-dengan-prism-js-pada-wordpress/","summary":"Beberapa waktu lalu, sesaat setelah mengganti theme blog ini dari TwentyFifteen menjadi Designer, saya mencari syntax highlighter untuk mempercantik (prettify) tampilan kode yang saya posting di sini. Dari hasil pencarian dengan Google, ada banyak yang bisa dipasang pada Wordpress. Namun, saya lebih tertarik untuk menggunakan prism.js. Alasannya sederhana: kombinasi warnanya yang saya rasa cocok dengan theme secara keseluruhan, ukuran file javascript maupun css yang sangat kecil sehingga waktu loading sangat cepat, mudah cara memasang dan menggunakannya, dan yang terpenting, prism.","title":"Syntax Highlighter dengan Prism.js pada Wordpress"},{"content":"Stemming merupakan proses menemukan kata dasar (root word) dari kata berimbuhan (affixed word) dengan cara menghilangkan semua imbuhan (affix) yang terdiri dari awalan (prefix), sisipan (infix), akhiran (suffix) dan kombinasi awalan dan akhiran (confix). Detail kata berimbuhan dalam bahasa Indonesia dan proses pembentukannya bisa dilihat pada artikel ini. Dalam text analytics, stemming merupakan salah satu proses penting yang sangat mempengaruhi kualitas hasil analisis. Ada banyak algoritma yang digunakan untuk melakukan proses stemming, diantaranya algoritma Nazief dan Andriani dan algoritma Porter.\n{% include base_path %}\n{% capture fig_img %} ![Root word]({{ base_path }}/img/blog/2015-12-16-katadasar-stemming-bahasa-indonesia-dengan-r/root words.jpg) {% endcapture %}\n{{ fig_img | markdownify | remove: \"\" | remove: \"\n\" }}\rIllustration from k5learning.com\rDi internet, banyak sekali informasi terkait stemming bahasa Indonesia bahkan source code-nya pun tersedia. Silakan Googling untuk infomasi lebih lengkap :) Namun, tidak demikian dengan R. Saya kesulitan untuk untuk menemukan R package untuk keperluan stemming bahasa Indonesia. Karena itulah saya membuat package katadasaR.\nkatadasaR adalah package yang berisi fungsi untuk stemming bahasa Indonesia dengan R menggunakan algoritma Nazief dan Andriani. Ini [bukanlah karya saya]{.highlight} sepenuhnya sebab saya hanya menulis ulang kode C-Sharp dari blog csharp-indonesia.com ke dalam bahasa R.\nFitur katadasaR melakukan stemming kata-per-kata dengan mengacu pada kamus kata dasar yang secara default sudah tersedia pada package.\nkatadasaR dilengkapi fungsi untuk menghapus imbuhan berikut:\nAwalan, seperti bertemu, dimakan Akhiran, seperti makanan, miliknya Kombinasi awalan dan akhiran, seperti pertemuan, mempermainkan Namun, untuk saat ini katadasaR belum bisa digunakan untuk:\nMenghapus sisipan, misalnya er dari seruling, el dari selidik Menghapus sisipan kata serapan, misalnya isme dari nasionali sme Menghapus imbuhan dari pengulanan kata, misalnya bermain-main, bermaaf-maafan Menambahkan kamus atau list kata dasar (dalam pengembangan) Dan lain-lain (infokan berbagai bugs di Github) Instalasi Saat ini masih dalam tahap pengembangan dan hanya tersedia di repo Github. Untuk instal package katadasaR, silakan gunakan fungsi devtools::install_github() berikut:\n# install_packages(\u0026#34;devtools\u0026#34;) library(devtools) install_github(\u0026#34;nurandi/katadasaR\u0026#34;) Penggunaan katadasaR hanya mampu melakukan stemming terhadap satu kata, bukan frase atau kalimat. Untuk stemming kalimat, silakan split kalimat menjadi kata-kata lalu gunakan fungsi katadasaR dalam loop. Contoh:\nlibrary(katadasaR) katadasaR(\u0026#34;makanan\u0026#34;) # output: # [1] \u0026#34;makan\u0026#34; words \u0026lt;- c(\u0026#34;jakarta\u0026#34;, \u0026#34;seminar\u0026#34;, \u0026#34;penggunaan\u0026#34;, \u0026#34;menggurui\u0026#34;, \u0026#34;pelajaran\u0026#34;, \u0026#34;dimana\u0026#34;) sapply(words, katadasaR) # output # jakarta seminar penggunaan menggurui pelajaran dimana # \u0026#34;jakarta\u0026#34; \u0026#34;seminar\u0026#34; \u0026#34;guna\u0026#34; \u0026#34;guru\u0026#34; \u0026#34;ajar\u0026#34; \u0026#34;mana\u0026#34; Acknowledgement csharp-indonesia.com\nSemoga bermanfaat :)\n","permalink":"/blog/katadasar-stemming-bahasa-indonesia-dengan-r/","summary":"Stemming merupakan proses menemukan kata dasar (root word) dari kata berimbuhan (affixed word) dengan cara menghilangkan semua imbuhan (affix) yang terdiri dari awalan (prefix), sisipan (infix), akhiran (suffix) dan kombinasi awalan dan akhiran (confix). Detail kata berimbuhan dalam bahasa Indonesia dan proses pembentukannya bisa dilihat pada artikel ini. Dalam text analytics, stemming merupakan salah satu proses penting yang sangat mempengaruhi kualitas hasil analisis. Ada banyak algoritma yang digunakan untuk melakukan proses stemming, diantaranya algoritma Nazief dan Andriani dan algoritma Porter.","title":"katadasaR : Stemming Bahasa Indonesia dengan R"},{"content":"Beberapa waktu lalu, di kolom [komentar]({{ site.url }}{{ site.baseurl }}/blog/twitter-mengolah-data-twitter-hasil-crawling/#comment1) dalam blog ini, ada yang nanya bagaimana caranya ekspor data dari R ke file CSV (comma separated values). Oke, di sini akan saya jelaskan.\nEkspor data dari R ke file teks (seperti CSV, tab separated value, dan lain-lain) sangatlah mudah. Ada beberapa fungsi yang biasa saya gunakan, di antaranya write.csv() dan write.table. Keduanya ada pada package base utils yang merupakan package base (bawaan) sehingga kita tidak perlu repot-repot menginstal package tambahan. Mari kita lihat satu per satu.\nFungsi write.csv() Digunakan untuk ekspor (menulis) data frame atau matrix ke file teks dengan format comma separated value. Maksudnya, setiap kolom dalam file ini dipisahkan oleh koma. Misalnya, kita akan mengekspor data frame mydf ke file myfile.csv, maka kita bisa gunakan fungsi sebagai berikut:\nwrite.csv(mydf, file=\u0026#34;myfile.csv\u0026#34;) Secara default, write.csv akan menambahkan row.names pada kolom pertama. Jika tidak diperlukan, kita dapat tambahkan parameter row.names=FALSE ke dalam fungsi di atas, sehingga menjadi:\nwrite.csv(mydf, file=\u0026#34;myfile.csv\u0026#34;, row.names=FALSE) Ada banyak parameter yang bisa digunakan. Silakan jalankan ?write.csv pada R console. :)\nFungsi write.table() Dalam hal kegunaan dan cara menggunakannya, fungsi ini hampir sama seperti write.csv(). Hanya saja pemisah kolom yang digunakan pada write.table() secara default adalah tab spasi. Dibandingkan dengan write.csv(), fungsi write.table() mempunyai banyak parameter. Saya biasanya menggunakan fungsi ini saat akan menambahkan baris-baris data baru ke file yang sudah ada (append), dengan menambahkan parameter append=TRUE.\nBagaimana, mudah bukan \u0026hellip;?\nJika ada yang kesulitan, mari kita diskusikan bersama :)\n","permalink":"/blog/ekspor-data-r-ke-text-file/","summary":"Beberapa waktu lalu, di kolom [komentar]({{ site.url }}{{ site.baseurl }}/blog/twitter-mengolah-data-twitter-hasil-crawling/#comment1) dalam blog ini, ada yang nanya bagaimana caranya ekspor data dari R ke file CSV (comma separated values). Oke, di sini akan saya jelaskan.\nEkspor data dari R ke file teks (seperti CSV, tab separated value, dan lain-lain) sangatlah mudah. Ada beberapa fungsi yang biasa saya gunakan, di antaranya write.csv() dan write.table. Keduanya ada pada package base utils yang merupakan package base (bawaan) sehingga kita tidak perlu repot-repot menginstal package tambahan.","title":"Ekspor Data R ke Text File"},{"content":"Mmmm \u0026hellip; tidak terlalu mudah, memang. Berikut adalah delapan langkah mudah untuk menjadi seorang data scientist menurut DataCamp.com\nGet good at stats, math and machine learning Ketiga skill ini sangat mendasar bagi seorang data scientist. Jika tidak bisa belajar di bangku universitas, kita bisa belajar secara online misalnya melalui Udacity, Coursera dan UDemy.\n{% capture fig_img %} ![How-to-become-a-data-scientist-Datacamp]({{ site.url }}{{ site.base_url }}/img/blog/2015-05-13-langkah-mudah-menjadi-data-scientist/datacamp-How-to-become-a-data-scientist.jpg) {% endcapture %}\n{% capture fig_caption %} Become a data scientist in 8 steps: the infographic (DataCamp.com) {% endcapture %}\n{{ fig_img | markdownify | remove: \"\" | remove: \"\n\" }}\r{{ fig_caption | markdownify | remove: \"\" | remove: \"\n\" }}\rLearn to code Mencakup dasar-dasar ilmu komputer dan belajar membuat code misalnya dengan SAS, R atau Python.\nUnderstand databases Berbeda dengan saat belajar di universitas, di perusahaan data hampir selalu disimpan dalam database (misalnya MySQL, Teradata, Netezza), bukan lagi dalam file teks.\nMaster data munging, visualization and reporting Data munging berarti melakukan transformasi terhadap raw data menjadi format lain yang lebih mudah digunakan. Sementara visualizaton and reporting mencakup pembuatan representasi visual dari data serta menyajikan analisis berikut hasilnya ke dalam laporan yang konprehensif.\nLevel up with Big Data Saat ini, bagi kebanyakan data scientiest, bekerja dengan menggunakan satu mesin saja tidak cukup dikarenakan data yang sangat besar.\nGet experience, practice and meet fellows data scientists Misalnya dengan mengikuti kompetisi serta mengikuti pertemuan atau seminar bersama sesama data scientist.\nInternship, bootcamp or get a job Ini adalah jalan terbaik untuk membuktikan apakah kita benar-benar seorang data scientist.\nFellow and and engage with the community Misalnya dengan menjadi member atau subscriber website data scientiest dan follow twitter data scientist.\nBagaimana menurut Anda?\n","permalink":"/blog/langkah-mudah-menjadi-data-scientist/","summary":"Mmmm \u0026hellip; tidak terlalu mudah, memang. Berikut adalah delapan langkah mudah untuk menjadi seorang data scientist menurut DataCamp.com\nGet good at stats, math and machine learning Ketiga skill ini sangat mendasar bagi seorang data scientist. Jika tidak bisa belajar di bangku universitas, kita bisa belajar secara online misalnya melalui Udacity, Coursera dan UDemy.\n{% capture fig_img %} ![How-to-become-a-data-scientist-Datacamp]({{ site.url }}{{ site.base_url }}/img/blog/2015-05-13-langkah-mudah-menjadi-data-scientist/datacamp-How-to-become-a-data-scientist.jpg) {% endcapture %}\n{% capture fig_caption %} Become a data scientist in 8 steps: the infographic (DataCamp.","title":"Langkah Mudah Menjadi Data Scientist"},{"content":"Beberapa waktu lalu saya diminta untuk menjelaskan logic dari SQL script yang saya buat ke salah salah satu rekan. \u0026ldquo;Belum ngerti\u0026rdquo;, katanya, \u0026ldquo;banyak over partition-nya\u0026rdquo;. Padahal OVER PARTITION adalah salah satu fitur SQL yang sangat saya andalkan, sehingga jangan heran jika banyak script yang saya tulis mengandung fungsi itu di dalamnya. Apa sebenarnya fungsi dari fitur ini dan bagaimana penggunaannya. Mari kita lihat apa dan bagaimana fungsi OVER dan PARTITION BY pada SQL bekerja.\nOVER Digunakan untuk mendapatkan nilai aggregat (seperti SUM, AVG, COUNT, MIN, MAX) tanpa menggunakan GROUP BY. Dengan OVER kita tetap mendapatkan seluruh baris secara detail beserta nilai aggregatnya. Mari kita gunakan tabel Orders berikut:\n| REGION | PRODUCT | QTY |\r|:------:|:----------:|:---:|\r| east | desktop | 332 |\r| east | notebook | 350 |\r| east | software | 125 |\r| center | tablet | 325 |\r| center | smartphone | 550 |\r| center | desktop | 186 |\r| center | notebook | 220 |\r| center | software | 54 |\r| west | tablet | 432 |\r| west | smartphone | 621 |\r| west | desktop | 125 |\r| west | notebook | 188 |\r| west | software | 75 |\r| west | camera | 65 |\rQuery:\nSELECT * , SUM(Qty) OVER() Sum_qty FROM Orders; Akan menghasilkan:\n| REGION | PRODUCT | QTY | SUM_QTY |\r|:------:|:----------:|:---:|:-------:|\r| east | desktop | 332 | 3648 |\r| east | notebook | 350 | 3648 |\r| east | software | 125 | 3648 |\r| west | tablet | 432 | 3648 |\r| west | smartphone | 621 | 3648 |\r| west | desktop | 125 | 3648 |\r| west | notebook | 188 | 3648 |\r| west | software | 75 | 3648 |\r| west | camera | 65 | 3648 |\r| center | tablet | 325 | 3648 |\r| center | smartphone | 550 | 3648 |\r| center | desktop | 186 | 3648 |\r| center | notebook | 220 | 3648 |\r| center | software | 54 | 3648 |\rSUM(Qty) OVER() jika diterjemahkan kurang lebih berarti\nSUM(Qty) : hitung jumlah Qty OVER : untuk semua baris () : secara keseluruhan OVER (PARTITION BY) Pada contoh di atas, Sum_qty adalah jumlah Qty dari seluruh baris yang ada pada dataset. Kita dapat memisahkan hasil perhitungan dengan menggunakan PARTITION BY.\nSELECT * , SUM(Qty) OVER(PARTITION BY Product) Sum_qty FROM orders; Hasilnya:\n| REGION | PRODUCT | QTY | SUM_QTY |\r|:------:|:----------:|:---:|:-------:|\r| east | software | 125 | 254 |\r| center | software | 54 | 254 |\r| west | software | 75 | 254 |\r| east | desktop | 332 | 643 |\r| center | desktop | 186 | 643 |\r| west | desktop | 125 | 643 |\r| center | tablet | 325 | 757 |\r| west | tablet | 432 | 757 |\r| west | camera | 65 | 65 |\r| east | notebook | 350 | 758 |\r| center | notebook | 220 | 758 |\r| west | notebook | 188 | 758 |\r| center | smartphone | 550 | 1171 |\r| west | smartphone | 621 | 1171 |\rPartisi yang saya gunakan adalah Product. Artinya, setiap produk akan diperlakukan secara terpisah dengan produk lainnya. Sehingga saya akan dapatkan total quantity untuk produk software, kemudian total untuk desktop dan seterusnya.\nJika diterjemahkan, SUM(Qty) OVER(PARTITION BY Product) berarti\nSUM(Qty) : hitung jumlah Qty OVER : untuk semua baris (PARTITION BY Product) : yang mempunyai produk yang sama Bandingkan dengan GROUP BY\nSELECT SUM(Qty) Sum_qty FROM Orders GROUP BY Product; | PRODUCT | SUM_QTY |\r|:----------:|:-------:|\r| software | 254 |\r| desktop | 643 |\r| tablet | 757 |\r| camera | 65 |\r| notebook | 758 |\r| smartphone | 1171 |\rTanpa menggunakan OVER(PARTITION BY), query berikut akan memberikan hasil yang sama (tentu lebih kompleks, ya):\nSELECT t0.* , t1.Sum_qty FROM Orders t0 JOIN ( SELECT SUM(Qty) Sum_qty FROM Orders GROUP BY Product ) t1 ON t0.Product = t1.Product; Mudah bukan?\nBerikut dua contoh penggunaan fungsi OVER PARTITION :\nMenghilangkan duplikat Dari setiap region akan diambil satu baris saja, yaitu baris dengan Qty terendah. Untuk tujuan ini kita dapat menggunakan fungsi aggregat ROW_NUMBER(). Sebagai catatan, fungsi ini membutuhkan tambahan perintah ORDER BY.\nSELECT Region, Product, Qty FROM ( SELECT * , ROW_NUMBER() OVER(PARTITION BY Region ORDER BY Qty) Obs FROM Orders ) t0 WHERE Obs = 1; | REGION | PRODUCT | QTY |\r|:------:|:--------:|:---:|\r| center | software | 54 |\r| west | camera | 65 |\r| east | software | 125 |\rMengambil sekian persen per kategori Dari setiap region akan diambil \u0026ldquo;Top 50% Product\u0026rdquo;.\nSELECT Region, Product, Qty, Obs FROM ( SELECT * , ROW_NUMBER() OVER(PARTITION BY Region ORDER BY Qty DESC) Obs , COUNT(*) OVER(PARTITION BY Region) Ctn FROM Orders ) t0 WHERE Obs \u0026lt;= CEIL(0.5*Ctn); | REGION | PRODUCT | QTY | OBS |\r|:------:|:----------:|:---:|:---:|\r| center | smartphone | 550 | 1 |\r| center | tablet | 325 | 2 |\r| center | notebook | 220 | 3 |\r| west | smartphone | 621 | 1 |\r| west | tablet | 432 | 2 |\r| west | notebook | 188 | 3 |\r| east | notebook | 350 | 1 |\r| east | desktop | 332 | 2 |\rPunya contoh lain? Mari kita diskusikan.\nSemoga bermanfaat :)\n","permalink":"/blog/over-dan-partition-by-pada-sql/","summary":"Beberapa waktu lalu saya diminta untuk menjelaskan logic dari SQL script yang saya buat ke salah salah satu rekan. \u0026ldquo;Belum ngerti\u0026rdquo;, katanya, \u0026ldquo;banyak over partition-nya\u0026rdquo;. Padahal OVER PARTITION adalah salah satu fitur SQL yang sangat saya andalkan, sehingga jangan heran jika banyak script yang saya tulis mengandung fungsi itu di dalamnya. Apa sebenarnya fungsi dari fitur ini dan bagaimana penggunaannya. Mari kita lihat apa dan bagaimana fungsi OVER dan PARTITION BY pada SQL bekerja.","title":"OVER dan PARTITION BY pada SQL"},{"content":"Tentu saja saya tidak akan membahas novel \u0026ldquo;50 Shades of Gray\u0026rdquo; karya E. L. James yang film-nya baru-baru ini dirilis, melainkan tentang gradasi warna hitam ke putih (abu-abu atau grey) dalam R. Tidak mau dikatakan menjiplak, tapi memang lebih dari 90% isi artikel ini saya ambil dari tulisannya Andy Nicholls. All credit goes to him. Terima kasih juga pada Gregory Piatetsky yang telah berbagi artikel tersebut di twitter.\nWhy limit yourself to \u0026quot;50 Shades of Grey?\u0026quot; R has 102 shades of grey #rstats http://t.co/hDLXsgMhv3 pic.twitter.com/6enmkfOzAS\n\u0026mdash; KDnuggets (@kdnuggets) February 15, 2015\rR mempunyai lebih dari 100 shades of grey, tidak hanya 50!. Mari kita lihat. Pertama, kita dapat menemukan 224 nama warna yang mengandung kata \u0026ldquo;gray\u0026rdquo; atau \u0026ldquo;grey\u0026rdquo; pada vektor yang dihasilkan oleh fungsi colours().\ngreys \u0026lt;- grep(\u0026#34;gr[ea]y\u0026#34;, colours(), value = TRUE) length(greys) # [1] 224 Kita masih menemukan warna dengan nama seperti \u0026ldquo;slategrey\u0026rdquo;, \u0026ldquo;darkgrey\u0026rdquo; dan \u0026ldquo;dimgrey\u0026rdquo;, sehingga mari kita abaikan semua warna selain \u0026ldquo;gray\u0026rdquo; atau \u0026ldquo;grey\u0026rdquo;. Tentu saja ini hanya berdasarkan penamaan warna. Jika kita mendefinisikan warna menggunakan RGB, kita bisa mendapatkan 256 warna abu-abu.\ngreys \u0026lt;- grep(\u0026#34;^gr[ea]y\u0026#34;, colours(), value = TRUE) length(greys) # [1] 204 Sehingga kita mendapatkan 204 warna \u0026ldquo;gray\u0026rdquo; atau \u0026ldquo;grey\u0026rdquo;. Tapi tunggu. Jika kita lihat lebih dalam, kita bisa menggunakan \u0026ldquo;gray\u0026rdquo; maupun \u0026ldquo;grey\u0026rdquo; dalam R. Sehingga sebenarnya warna abu-abu dalam R bukanlah berjumlah 204 karena adanya duplikasi. Sehingga, mari kita ambil salah satunya saja:\ngreys \u0026lt;- grep(\u0026#34;^grey\u0026#34;, colours(), value = TRUE) length(greys) # [1] 102 Sehingga kita punya 102 Shades of Grey dalam R!\nmatrix(greys,ncol=6,byrow=T) # [,1] [,2] [,3] [,4] [,5] [,6] # [1,] \u0026#34;grey\u0026#34; \u0026#34;grey0\u0026#34; \u0026#34;grey1\u0026#34; \u0026#34;grey2\u0026#34; \u0026#34;grey3\u0026#34; \u0026#34;grey4\u0026#34; # [2,] \u0026#34;grey5\u0026#34; \u0026#34;grey6\u0026#34; \u0026#34;grey7\u0026#34; \u0026#34;grey8\u0026#34; \u0026#34;grey9\u0026#34; \u0026#34;grey10\u0026#34; # [3,] \u0026#34;grey11\u0026#34; \u0026#34;grey12\u0026#34; \u0026#34;grey13\u0026#34; \u0026#34;grey14\u0026#34; \u0026#34;grey15\u0026#34; \u0026#34;grey16\u0026#34; # [4,] \u0026#34;grey17\u0026#34; \u0026#34;grey18\u0026#34; \u0026#34;grey19\u0026#34; \u0026#34;grey20\u0026#34; \u0026#34;grey21\u0026#34; \u0026#34;grey22\u0026#34; # [5,] \u0026#34;grey23\u0026#34; \u0026#34;grey24\u0026#34; \u0026#34;grey25\u0026#34; \u0026#34;grey26\u0026#34; \u0026#34;grey27\u0026#34; \u0026#34;grey28\u0026#34; # [6,] \u0026#34;grey29\u0026#34; \u0026#34;grey30\u0026#34; \u0026#34;grey31\u0026#34; \u0026#34;grey32\u0026#34; \u0026#34;grey33\u0026#34; \u0026#34;grey34\u0026#34; # [7,] \u0026#34;grey35\u0026#34; \u0026#34;grey36\u0026#34; \u0026#34;grey37\u0026#34; \u0026#34;grey38\u0026#34; \u0026#34;grey39\u0026#34; \u0026#34;grey40\u0026#34; # [8,] \u0026#34;grey41\u0026#34; \u0026#34;grey42\u0026#34; \u0026#34;grey43\u0026#34; \u0026#34;grey44\u0026#34; \u0026#34;grey45\u0026#34; \u0026#34;grey46\u0026#34; # [9,] \u0026#34;grey47\u0026#34; \u0026#34;grey48\u0026#34; \u0026#34;grey49\u0026#34; \u0026#34;grey50\u0026#34; \u0026#34;grey51\u0026#34; \u0026#34;grey52\u0026#34; # [10,] \u0026#34;grey53\u0026#34; \u0026#34;grey54\u0026#34; \u0026#34;grey55\u0026#34; \u0026#34;grey56\u0026#34; \u0026#34;grey57\u0026#34; \u0026#34;grey58\u0026#34; # [11,] \u0026#34;grey59\u0026#34; \u0026#34;grey60\u0026#34; \u0026#34;grey61\u0026#34; \u0026#34;grey62\u0026#34; \u0026#34;grey63\u0026#34; \u0026#34;grey64\u0026#34; # [12,] \u0026#34;grey65\u0026#34; \u0026#34;grey66\u0026#34; \u0026#34;grey67\u0026#34; \u0026#34;grey68\u0026#34; \u0026#34;grey69\u0026#34; \u0026#34;grey70\u0026#34; # [13,] \u0026#34;grey71\u0026#34; \u0026#34;grey72\u0026#34; \u0026#34;grey73\u0026#34; \u0026#34;grey74\u0026#34; \u0026#34;grey75\u0026#34; \u0026#34;grey76\u0026#34; # [14,] \u0026#34;grey77\u0026#34; \u0026#34;grey78\u0026#34; \u0026#34;grey79\u0026#34; \u0026#34;grey80\u0026#34; \u0026#34;grey81\u0026#34; \u0026#34;grey82\u0026#34; # [15,] \u0026#34;grey83\u0026#34; \u0026#34;grey84\u0026#34; \u0026#34;grey85\u0026#34; \u0026#34;grey86\u0026#34; \u0026#34;grey87\u0026#34; \u0026#34;grey88\u0026#34; # [16,] \u0026#34;grey89\u0026#34; \u0026#34;grey90\u0026#34; \u0026#34;grey91\u0026#34; \u0026#34;grey92\u0026#34; \u0026#34;grey93\u0026#34; \u0026#34;grey94\u0026#34; # [17,] \u0026#34;grey95\u0026#34; \u0026#34;grey96\u0026#34; \u0026#34;grey97\u0026#34; \u0026#34;grey98\u0026#34; \u0026#34;grey99\u0026#34; \u0026#34;grey100\u0026#34; Atau dalam colors palette (script R untuk menghasilkan colors palette ini saya modifikasi dari Earl F. Glynn\u0026rsquo;s Color Chart):\ngreys = grep(\u0026#34;^grey\u0026#34;, colours(), value = TRUE) colCount \u0026lt;- 6 rowCount \u0026lt;- 17 plot( c(1,colCount), c(0,rowCount), type=\u0026#34;n\u0026#34;, ylab=\u0026#34;\u0026#34;, xlab=\u0026#34;\u0026#34;, axes=FALSE, ylim=c(rowCount,0)) title(\u0026#34;R\u0026#39;s 102 Shades of Grey\u0026#34;) for (j in 0:(rowCount-1)) { base \u0026lt;- j*colCount remaining \u0026lt;- length(greys) - base RowSize \u0026lt;- ifelse(remaining \u0026lt; colCount, remaining, colCount) rect((1:RowSize)-0.5,j-0.5, (1:RowSize)+0.5,j+0.5, border=\u0026#34;black\u0026#34;, col=greys[base + (1:RowSize)]) text((1:RowSize), j, greys[j*RowSize + 1:RowSize], cex=0.7, col=(ifelse(j\u0026lt;=8, \u0026#34;white\u0026#34;, \u0026#34;black\u0026#34;))) } ![R-102-shades-of-grey]({{ site.url }}{{ site.baseurl }}/img/blog/2015-02-19-50-shades-of-grey/R-102-shades-of-grey.png)\nLalu bagaimana mendapatkan 50 Shades of Grey? Fungsi colorRampPalette dapat digunakan untuk menghasilkan warna-warna baru berdasarkan warna yang kita tentukan. Sehingga *colors palette di antara \u0026ldquo;grey0\u0026rdquo; (hitam) dan \u0026ldquo;grey100\u0026rdquo; (putih) dapat dibuat dengan mudah.\nshadesOfGrey \u0026lt;- colorRampPalette(c(\u0026#34;grey0\u0026#34;, \u0026#34;grey100\u0026#34;)) shadesOfGrey(2) # [1] \u0026#34;#000000\u0026#34; \u0026#34;#FFFFFF\u0026#34; Dengan kode berikut, kita bisa mendapatkan 50 Shades of Grey versi R.\nfiftyGreys \u0026lt;- shadesOfGrey(50) mat \u0026lt;- matrix(rep(1:50, each = 50)) image(mat, axes = FALSE, col = fiftyGreys) box() ![R-50-shades-of-grey]({{ site.url }}{{ site.baseurl }}/img/blog/2015-02-19-50-shades-of-grey/R-50-shades-of-grey.png)\nSo, why limit yourself to \u0026ldquo;50 Shades of Grey\u0026rdquo;?\n","permalink":"/blog/50-shades-of-grey/","summary":"Tentu saja saya tidak akan membahas novel \u0026ldquo;50 Shades of Gray\u0026rdquo; karya E. L. James yang film-nya baru-baru ini dirilis, melainkan tentang gradasi warna hitam ke putih (abu-abu atau grey) dalam R. Tidak mau dikatakan menjiplak, tapi memang lebih dari 90% isi artikel ini saya ambil dari tulisannya Andy Nicholls. All credit goes to him. Terima kasih juga pada Gregory Piatetsky yang telah berbagi artikel tersebut di twitter.\nWhy limit yourself to \u0026quot;50 Shades of Grey?","title":"\"50 Shades of Grey\""},{"content":"GitHut.info menampilkan statistik tentang aktivitas bahasa pemrograman di GitHub menurut jumlah repositori, pushes, forks dan lain-lain. Dari situs tersebut dapat dilihat bahwa R semakin populer di GitHub dari waktu ke waktu. Pada kuarter ke-4 2014, R menempati urutan ke-12 sebagai bahasa pemrograman dengan jumlah repositori aktif terbanyak (34K repositori). Suatu repositori dianggap aktif jika pada periode ini minimal ada satu perubahan/perbaikan pada kode yang dikirim dari repositori lokal ke GitHub.com (push). Tiga besar pada kategori ini berturut-turut adalah JavaScript, Java dan Python.\n{% include base_path %}\n{% capture fig_img %} ![GitHut.info]({{ base_path }}/img/blog/2015-02-19-r-semakin-populer-di-github/GitHut.png) {% endcapture %}\n{{ fig_img | markdownify | remove: \"\" | remove: \"\n\" }}\rGitHut.info menampilkan statistik aktifitas bahasa pemrograman pada GitHub.com Pencapaian lain, seperti di tulis oleh Stephen Turner pada kicauannya:\nOn GitHub, #Rstats has more new forks per repo than any other language http://t.co/9w6jYyWNtR pic.twitter.com/nPb8MfOR1Z\n\u0026mdash; Stephen Turner (@genetics_blog) February 11, 2015\rR mempunyai rata-rata forks baru per repositori tertinggi dibandingkan bahasa pemrograman apapun. Artinya, kode R sedang digunakan dan dimodifikasi secara aktif oleh banyak pengguna GitHub (sumber: David Smith pada Blog RevolutionAnalytics).\n","permalink":"/blog/r-semakin-populer-di-github/","summary":"GitHut.info menampilkan statistik tentang aktivitas bahasa pemrograman di GitHub menurut jumlah repositori, pushes, forks dan lain-lain. Dari situs tersebut dapat dilihat bahwa R semakin populer di GitHub dari waktu ke waktu. Pada kuarter ke-4 2014, R menempati urutan ke-12 sebagai bahasa pemrograman dengan jumlah repositori aktif terbanyak (34K repositori). Suatu repositori dianggap aktif jika pada periode ini minimal ada satu perubahan/perbaikan pada kode yang dikirim dari repositori lokal ke GitHub.com (push).","title":"R Semakin Populer di GitHub"},{"content":"Menyambung diskusi kita tentang bagaimana crawling data Twitter menggunakan package twitteR pada R, kali ini mari kita bahas bagaimana mengolah data tersebut. Raw-data yang diperoleh dari hasil crawling sebagian besar berupa list. searchTwitter() dan userTimeline() menghasilkan list dari objek status. Setiap elemen pada list tersebut berisi detail tweet yang sesuai dengan kriteria pencarian yang ditentukan. Output getUser() berupa objek user, sementara lookupUsers() berupa list dari objek user, di mana setiap elemennya berisi detail dari user. Untuk mengolah data twitter hasil crawling, kita harus mengenal objek-objek tersebut. Berikut penjelasan lebih detail mengenai objek status dan objek user:\nObjek status Dihasilkan oleh fungsi searchTwitter() dan userTimeline(), misalnya:\ntw.bogor = searchTwitter(\u0026#34;bogor\u0026#34;, n=500) user.tl = userTimeline(\u0026#34;nurandi\u0026#34;, n=500) Untuk mengetahui tipe data tersebut, gunakan fungsi mode(tw.bogor) dan mode(user.tl). Keduanya adalah list. Sedangkan struktur datanya bisa dilihat dengan fungsi str(). Setiap elemen pada list mempunyai struktur yang sama, sehingga untuk mengetahui struktur data, kita cukup lihat satu elemen saja, misalnya: str(tw.bogor[1]) atau str(user.tl[1]). Outputnya adalah sebagai berikut:\n$ :Reference class 'status' [package \u0026quot;twitteR\u0026quot;] with 17 fields\r..$ text : chr \u0026quot;Testimoni MASKER SPIRULINA http://t.co/s96cHQKKim SMS: 089676926626 | HERBAL, BPOM #Cisarua #Bogor\u0026quot;\r..$ favorited : logi FALSE\r..$ favoriteCount: num 0\r..$ replyToSN : chr(0) ..$ created : POSIXct[1:1], format: \u0026quot;2015-02-07 00:29:38\u0026quot;\r..$ truncated : logi FALSE\r..$ replyToSID : chr(0) ..$ id : chr \u0026quot;563857078658154496\u0026quot;\r..$ replyToUID : chr(0) ..$ statusSource : chr \u0026quot;\u0026lt;a href=\u0026quot;http://twittbot.net/\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;twittbot.net\u0026lt;/a\u0026gt;\u0026quot;\r..$ screenName : chr \u0026quot;TiensCisarua\u0026quot;\r..$ retweetCount : num 0\r..$ isRetweet : logi FALSE\r..$ retweeted : logi FALSE\r..$ longitude : chr(0) ..$ latitude : chr(0) ..$ urls :'data.frame': 0 obs. of 4 variables:\r.. ..$ url : chr(0) .. ..$ expanded_url: chr(0) .. ..$ dispaly_url : chr(0) .. ..$ indices : num(0) ..and 51 methods, of which 39 are possibly relevant:\r.. getCreated, getFavoriteCount, getFavorited, getId, getIsRetweet, getLatitude,\r.. getLongitude, getReplyToSID, getReplyToSN, getReplyToUID, getRetweetCount,\r.. getRetweeted, getRetweeters, getRetweets, getScreenName, getStatusSource, getText,\r.. getTruncated, getUrls, initialize, setCreated, setFavoriteCount, setFavorited,\r.. setId, setIsRetweet, setLatitude, setLongitude, setReplyToSID, setReplyToSN,\r.. setReplyToUID, setRetweetCount, setRetweeted, setScreenName, setStatusSource,\r.. setText, setTruncated, setUrls, toDataFrame, toDataFrame#twitterObj\rDari output di atas kita dapat lihat bahwa objek status terdiri dari 17 variabel (text, favorited, \u0026hellip;, urls). Gunakan perintah ?status pada R console untuk mengetahui keterangan tiap-tiap variabel.\nObjek user Dihasilkan oleh fungsi getUser() dan lookupUsers(), misalnya:\nuser = getUser(\u0026#34;nurandi\u0026#34;) users = lookupUsers(c(\u0026#34;nurandi\u0026#34;,\u0026#34;prabowo08\u0026#34;,\u0026#34;jokowi_do2\u0026#34;)) user adalah objek S4, sedangkan users adalah list. Setiap elemen pada objek users mempunyai struktur yang sama dengan objek user. Berikut adalah keluaran dari fungsi str(user).\nReference class 'user' [package \u0026quot;twitteR\u0026quot;] with 18 fields\r$ description : chr \u0026quot;Oh God ! This is so sexy ....\u0026quot;\r$ statusesCount : num 255\r$ followersCount : num 196\r$ favoritesCount : num 10\r$ friendsCount : num 229\r$ url : chr \u0026quot;http://t.co/2zFucAuWdD\u0026quot;\r$ name : chr \u0026quot;Nur Andi Setiabudi\u0026quot;\r$ created : POSIXct[1:1], format: \u0026quot;2009-07-22 12:13:06\u0026quot;\r$ protected : logi FALSE\r$ verified : logi FALSE\r$ screenName : chr \u0026quot;nurandi\u0026quot;\r$ location : chr \u0026quot;Jakarta - ID\u0026quot;\r$ lang : chr \u0026quot;en\u0026quot;\r$ id : chr \u0026quot;59108937\u0026quot;\r$ lastStatus :Reference class 'status' [package \u0026quot;twitteR\u0026quot;] with 17 fields\r..$ text : chr \u0026quot;RT @kdnuggets: Data scientist memes - the ‘hottest profession’: it's not the data size, it's how you use it! http://t.co/AJDi3q\u0026quot;| __truncated__\r..$ favorited : logi FALSE\r..$ favoriteCount: num 0\r..$ replyToSN : chr(0) ..$ created : POSIXct[1:1], format: \u0026quot;2015-02-05 11:24:56\u0026quot;\r..$ truncated : logi FALSE\r..$ replyToSID : chr(0) ..$ id : chr \u0026quot;563297217713545216\u0026quot;\r..$ replyToUID : chr(0) ..$ statusSource : chr \u0026quot;\u0026lt;a href=\u0026quot;http://twitter.com\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;Twitter Web Client\u0026lt;/a\u0026gt;\u0026quot;\r..$ screenName : chr \u0026quot;Unknown\u0026quot;\r..$ retweetCount : num 27\r..$ isRetweet : logi TRUE\r..$ retweeted : logi FALSE\r..$ longitude : chr(0) ..$ latitude : chr(0) ..$ urls :'data.frame': 1 obs. of 5 variables:\r.. ..$ url : chr \u0026quot;http://t.co/AJDi3qQywE\u0026quot;\r.. ..$ expanded_url: chr \u0026quot;http://buff.ly/1z5NYD5\u0026quot;\r.. ..$ display_url : chr \u0026quot;buff.ly/1z5NYD5\u0026quot;\r.. ..$ start_index : num 109\r.. ..$ stop_index : num 131\r..and 51 methods, of which 39 are possibly relevant:\r.. getCreated, getFavoriteCount, getFavorited, getId, getIsRetweet, getLatitude,\r.. getLongitude, getReplyToSID, getReplyToSN, getReplyToUID, getRetweetCount,\r.. getRetweeted, getRetweeters, getRetweets, getScreenName, getStatusSource, getText,\r.. getTruncated, getUrls, initialize, setCreated, setFavoriteCount, setFavorited,\r.. setId, setIsRetweet, setLatitude, setLongitude, setReplyToSID, setReplyToSN,\r.. setReplyToUID, setRetweetCount, setRetweeted, setScreenName, setStatusSource,\r.. setText, setTruncated, setUrls, toDataFrame, toDataFrame#twitterObj\r$ listedCount : num 4\r$ followRequestSent: logi FALSE\r$ profileImageUrl : chr \u0026quot;http://pbs.twimg.com/profile_images/2669346805/a7fe4a431fd3b401b3dd26fac1a10b98_normal.png\u0026quot;\rand 57 methods, of which 45 are possibly relevant:\rgetCreated, getDescription, getFavorites, getFavoritesCount, getFavouritesCount,\rgetFollowerIDs, getFollowers, getFollowersCount, getFollowRequestSent, getFriendIDs,\rgetFriends, getFriendsCount, getId, getLang, getLastStatus, getListedCount,\rgetLocation, getName, getProfileImageUrl, getProtected, getScreenName,\rgetStatusesCount, getUrl, getVerified, initialize, setCreated, setDescription,\rsetFavoritesCount, setFollowersCount, setFollowRequestSent, setFriendsCount, setId,\rsetLang, setLastStatus, setListedCount, setLocation, setName, setProfileImageUrl,\rsetProtected, setScreenName, setStatusesCount, setUrl, setVerified, toDataFrame,\rtoDataFrame#twitterObj\rObjek user terdiri dari 18 variabel. Untuk mengatahui penjelasan masing-masing variabel, buka dokumentasi dengan perintah ?user.\nMengakses variabel/kolom Kolom-kolom pada objeck status maupun user dapat diakses dengan menggunakan fungsi sapply(\u0026lt;nama-objek\u0026gt;,\u0026lt;nama-kolom\u0026gt;). Misalnya,\nUser yang menulis tweet tentang bogor:\nname = sapply(tw.bogor, screenName) Menampilkan teks tweet\ntext = sapply(tw.bogor, statusText) Melihat jumlah follower dari objek users\nnfollowers = sapply(users, followersCount) Konversi ke data frame Objek status maupun user dapat dikonversi menjadi data frame dengan fungsi twListToDF(). Misalnya:\ntw.bogor.df = twListToDF(tw.bogor) names(tw.bogor.df) # [1] \u0026#34;text\u0026#34; \u0026#34;favorited\u0026#34; \u0026#34;favoriteCount\u0026#34; \u0026#34;replyToSN\u0026#34; \u0026#34;created\u0026#34; # \u0026#34;truncated\u0026#34; # [7] \u0026#34;replyToSID\u0026#34; \u0026#34;id\u0026#34; \u0026#34;replyToUID\u0026#34; \u0026#34;statusSource\u0026#34; \u0026#34;screenName\u0026#34; \u0026#34;retweetCount\u0026#34; # [13] \u0026#34;isRetweet\u0026#34; \u0026#34;retweeted\u0026#34; \u0026#34;longitude\u0026#34; \u0026#34;latitude\u0026#34; head(tw.bogor.df$text) # [1] \u0026#34;Testimoni MASKER SPIRULINA http://t.co/s96cHQKKim SMS: 089676926626 | HERBAL, BPOM #Cisarua #Bogor\u0026#34; # [2] \u0026#34;He amin insyaalloh @MU_joybanget: @restinyunyun teh naha bisa geulis kitu ? Ameng atuh ka bogor xed�� xed�u0086”\u0026#34; # [3] \u0026#34;Hari ini endy shoot di PGB bogor\u0026#34; # [4] \u0026#34;RT @infobogor: Hari ini! @batiknight2015 | @KuntoAjiW @endahNrhesa @GBluesShelter | info 081286890980 http://t.co/yqemocVWGO http://t.co/pz…\u0026#34; # [5] \u0026#34;Weekendnya Dinas pagi dong xed��xed�u0086xed��xed�� (at puskesmas bogor selatan) — https://t.co/v2OpaFLTGx\u0026#34; # [6] \u0026#34;RT @Indiradewiputri: Selamat pagi Bogor ;;)\u0026#34; users.df = twListToDF(users) names(users.df) # [1] \u0026#34;description\u0026#34; \u0026#34;statusesCount\u0026#34; \u0026#34;followersCount\u0026#34; \u0026#34;favoritesCount\u0026#34; # [5] \u0026#34;friendsCount\u0026#34; \u0026#34;url\u0026#34; \u0026#34;name\u0026#34; \u0026#34;created\u0026#34; # [9] \u0026#34;protected\u0026#34; \u0026#34;verified\u0026#34; \u0026#34;screenName\u0026#34; \u0026#34;location\u0026#34; # [13] \u0026#34;lang\u0026#34; \u0026#34;id\u0026#34; \u0026#34;listedCount\u0026#34; \u0026#34;followRequestSent\u0026#34; # [17] \u0026#34;profileImageUrl\u0026#34; users.df$name # [1] \u0026#34;Nur Andi Setiabudi\u0026#34; \u0026#34;Prabowo Subianto\u0026#34; \u0026#34;Joko Widodo\u0026#34; ","permalink":"/blog/twitter-mengolah-data-twitter-hasil-crawling/","summary":"Menyambung diskusi kita tentang bagaimana crawling data Twitter menggunakan package twitteR pada R, kali ini mari kita bahas bagaimana mengolah data tersebut. Raw-data yang diperoleh dari hasil crawling sebagian besar berupa list. searchTwitter() dan userTimeline() menghasilkan list dari objek status. Setiap elemen pada list tersebut berisi detail tweet yang sesuai dengan kriteria pencarian yang ditentukan. Output getUser() berupa objek user, sementara lookupUsers() berupa list dari objek user, di mana setiap elemennya berisi detail dari user.","title":"twitteR: Mengolah Data Twitter Hasil Crawling"},{"content":"Analisis terhadap media/jejaring sosial (social media analytics) adalah alat yang ampuh untuk memahami sikap, preferensi dan opini publik di berbagai sumber online. Bagi sebuah organisasi atau perusahaan, analisis media sosial dapat memberikan keunggulan atas pesaing mereka melalui pengetahuan menyeluruh tentang bagaimana produk dan layanan mereka dirasakan oleh pelanggan atau calon pelanggan potensial. Analisis media sosial memungkinkan organisasi dan perusahan untuk membuat keputusan yang cerdas mengenai kebutuhan, sikap, pendapat, tren terbaru dan berbagai faktor yang mempengaruhi pelanggan (dari socialmediadata.com).\n{% include base_path %}\n{% capture fig_img %} ![Twitter]({{ site.url }}{{ site.baseurl }}/img/blog/2015-01-31-crawling-data-twitter-menggunakan-r/twitter-background.jpg) {% endcapture %}\n{{ fig_img | markdownify | remove: \"\" | remove: \"\n\" }}\rCredit: thedesk.matthewkeys.net\rKabar baiknya, data dari berbagai media sosial telah tersedia, walaupun masih berada di \u0026ldquo;awan\u0026rdquo;. Media sosial terbesar di dunia, Twitter dan Facebook, misalnya, menyediakan API/application program interface yang memungkinkan kita mendapatkan data mereka. Begitu juga dengan Google+, Instagram dan Path. Yang jadi pertanyaan, bagaimana kita bisa dapatkan data tersebut? Untuk menjawab pertanyaan tersebut lah artikel ini saya tulis.\nDalam artikel ini kita akan berdiskusi tentang bagaimana mengambil atau crawling data Twitter menggunakan R dengan memanfaatkan API. Untuk media lainnya (Facebook, Instagram, dan lain-lain), Insya Allah akan kita bahas pada kesempatan lain.\nInstal package twitteR twitteR (ditulis oleh geoffjentry) adalah R package yang menyediakan akses ke API Twitter sehingga memungkinkan kita melakukan crawling data Twitter menggunakan R. Instal versi terbaru twitteR dari GitHub menggunakan package devtools (jika belum).\nlibrary(devtools) install_github(\u0026#34;twitteR\u0026#34;, username=\u0026#34;geoffjentry\u0026#34;) library(twitteR) Lebih lengkap tentang bagaimana menginstall package twitteR dapat dilihat pada artikel ini.\nTwitter authentication Agar R dapat digunakan untuk mengekstrak data Twitter, terlebih dahulu kita harus mengirim sebuah secure authorized requests ke Twitter API. Proses ini dapat dilakukan dengan fungsi berikut:\napi_key = \u0026#34;isi dengan API key\u0026#34; api_secret = \u0026#34;isi dengan API secret\u0026#34; access_token = \u0026#34;isi dengan Access token\u0026#34; access_token_secret = \u0026#34;isi dengan Access token secret\u0026#34; setup_twitter_oauth(api_key, api_secret, access_token, access_token_secret) Kita harus mempunyai Twitter application untuk mendapatkan API key, API secret, access token dan access token secret. Bagaimana membuat Twitter application dan mendapatkan token bisa dilihat pada artikel ini.\nKetika fungsi dijalankan setup_twitter_oauth(), R console akan menanyakan: Use a local file to cache OAuth access credentials between R sessions?. Biasanya saya jawab 2.\nOke, pada tahapan ini kita sudah mendapatkan secure connection ke Twitter API dan R siap untuk mengambil data.\nSearch Twitter Untuk mendapatkan tweet yang berisi kata (keyword) tertentu, misalnya \u0026ldquo;bogor\u0026rdquo;, dapat dilakukan dengan fungsi berikut:\ntw.bogor = searchTwitter(\u0026#34;bogor\u0026#34;) Secara default, fungsi tersebut akan mengambil 25 tweet yang berisi kata \u0026ldquo;bogor\u0026rdquo;. Berikut adalah lima tweet pertama pada objek tw.bogor:\n[[1]]\r[1] \u0026quot;JoinTupperware: Visit http://t.co/TlhtJHHlDG untuk cek detail tentang Tupperware Bogor, Info \u0026amp; Order [PIN:29369518 - WA: 081297139078] #TupperwareBogor\u0026quot;\r[[2]]\r[1] \u0026quot;PolresBogorKota: Jadwal SIM Keliling Kota Bogor, Sabtu 31/1/2015, Lokasi Grha Pena Radar Bogor Taman Yasmin, Pkl. 09:00-12:00 WIB @RTMC_PoldaJabar\u0026quot;\r[[3]]\r[1] \u0026quot;rezadzulfikar: \u0026quot;SECOND CHANCE\u0026quot; - EXPO2015 - (at MAN 2 Bogor) [pic] — https://t.co/T8hEzpf4nL\u0026quot;\r[[4]]\r[1] \u0026quot;Tupperware_Info: Mau beli Produk Tupperware di Bogor secara Retail? hubungi [PIN:29369518 - WA: 081297139078] #TupperwareBogor\u0026quot;\r[[5]]\r[1] \u0026quot;KiteIPB: RT @Fithriyyah_27: KPMKB adlh organisasi mahasiswa KalBar yg berdomisili di Bogor @KiteIPB #MakeAChoice\u0026quot;\rGet Users Untuk lihat profil satu akun twitter, misalnya nama, deskripsi, jumlah follower dan following dan jumlah tweet, gunakan fungsi getUser():\nuser = getUser(\u0026#34;nurandi\u0026#34;) \u0026ldquo;nurandi\u0026rdquo; bisa diganti dengan akun twitter atau twitter ID.\nMisalnya, saya ingin melihat siapa saja followers dari \u0026ldquo;nurandi\u0026rdquo; :\nuser$getFollowers() Outputnya (lima pertama):\n$`3004628621`\r[1] \u0026quot;ayusri884\u0026quot;\r$`2994157963`\r[1] \u0026quot;putra_tasal\u0026quot;\r$`2941365294`\r[1] \u0026quot;Sneak_Pro\u0026quot;\r$`980172871`\r[1] \u0026quot;Imatumi1\u0026quot;\r$`2733762661`\r[1] \u0026quot;LaluMahsar\u0026quot;\rgetUser() hanya dapat digunakan untuk melihat profil satu akun. Jika banyak akun, gunakan fungsi lookupUsers(). Contohnya:\nusers = lookupUsers(c(\u0026#34;nurandi\u0026#34;,\u0026#34;prabowo08\u0026#34;,\u0026#34;jokowi_do2\u0026#34;)) Timeline Kita juga bisa meng-crawl timeline atau status twitter dari satu atau beberapa akun. Caranya :\nuser.tl = userTimeline(\u0026#34;nurandi\u0026#34;) Lima baris pertama objek user.tl adalah sebagai berikut:\n[[1]]\r[1] \u0026quot;nurandi: Membuat Word Cloud dengan R http://t.co/mSfd9QBjKi\u0026quot;\r[[2]]\r[1] \u0026quot;nurandi: Mengelola R Package http://t.co/JBA0K84bnk\u0026quot;\r[[3]]\r[1] \u0026quot;nurandi: @cygyt @lenimarlena waktu lu ke bali ga ngajak2 :D\u0026quot;\r[[4]]\r[1] \u0026quot;nurandi: Rabuan... @cygyt , @lenimarlena http://t.co/2c2bgeJCGs\u0026quot;\r[[5]]\r[1] \u0026quot;nurandi: @HimalkomIPB ada yg bisa jadi mentor programing with Python? Saya ingin belajar dan butuh mentor. Thanks\u0026quot;\rFungsi-fungsi yang kita diskusikan tadi merupakan fungsi dasar dan sebenarnya masih banyak parameter yang bisa ditambahkan. Untuk mengetahui fungsi-fungsi tersebut secara detail termasuk parameter yang bisa digunakan, ketik ? diikuti nama fungsi pada R console.\n{% include textbox text=\u0026quot;UPDATE (16 Jan 2019): Pada pertengahan 2016, Jeff Gentry, sang pengembang, menghentikan pengembangan dan update/maintenance package twitteR. Meskipun masih bisa digunakan (setidaknya sampai saat ini), Mr. Jeff merekomendasikan untuk beralih menggunakan package lain yang tidak kalah kerennya, yaitu rtweet. Bagaimana menggunakan package rtweet untuk crawling data Twitter sudah saya jabarkan pada artikel rtweet: Crawling Data Twitter Menggunakan R.\u0026quot; %}\nSelamat, kita sudah berhasil mendapatkan tweet yang berisi kata-kata tertentu, informasi/profil akun twitter dan timeline/status. Mudah bukan?\nLalu bagaimana selanjutnya? Apakah bisa kita mendapatkan informasi detail seperti kapan tweet tersebut di posting, ada berapa jumlah follower dari akun yang mem-posting tweet tertentu? Atau, bisa tidak kita simpan hasil crawling tersebut ke file .csv misalnya? Tentu saja bisa. Yang harus kita lakukan adalah melakukan sedikit manipulasi data. Silakan simak artikel berikut :)\n","permalink":"/blog/crawling-data-twitter-menggunakan-r/","summary":"Analisis terhadap media/jejaring sosial (social media analytics) adalah alat yang ampuh untuk memahami sikap, preferensi dan opini publik di berbagai sumber online. Bagi sebuah organisasi atau perusahaan, analisis media sosial dapat memberikan keunggulan atas pesaing mereka melalui pengetahuan menyeluruh tentang bagaimana produk dan layanan mereka dirasakan oleh pelanggan atau calon pelanggan potensial. Analisis media sosial memungkinkan organisasi dan perusahan untuk membuat keputusan yang cerdas mengenai kebutuhan, sikap, pendapat, tren terbaru dan berbagai faktor yang mempengaruhi pelanggan (dari socialmediadata.","title":"twitteR: Crawling Data Twitter Menggunakan R"},{"content":"Bagaimana menampilkan data teks agar menarik sekaligus mudah dipahami? Tentu akan lebih baik menggunakan grafik dibandingkan dengan bentuk tabel yang berisi angka-angka, bukan? Ada berbagai macam grafik yang bisa digunakan. Untuk data teks, word cloud adalah salah satu pilihan.\nApa itu word cloud ? Word cloud (disebut juga text cloud atau tag cloud) merupakan salah satu metode untuk menampilkan data teks secara visual. Grafik ini populer dalam text mining karena mudah dipahami. Dengan menggunakan word cloud, gambaran frekuensi kata-kata dapat ditampilkan dalam bentuk yang menarik namun tetap informatif. Semakin sering satu kata digunakan, maka semakin besar pula ukuran kata tersebut ditampilkan dalam word cloud.\nJika ingin mengetahui lebih detail tentang word cloud, artikel ini sayang untuk dilewatkan.\nMembuat word cloud dengan R Word cloud sangat mudah dibuat. Melalui situs seperti Wordle, Tagxedo dan Tag Crowd kita dapat membuat word cloud secara online dengan cepat. Sementara para pengguna R patut mengucapkan terimakasih kepada Ian Fellows yang telah menulis wordcloud, sebuah package untuk membuat word cloud dengan R. Package ini tersedia gratis di repositori CRAN.\nSecara garis besar, pembuatan word cloud dengan package wordcloud dapat dikerjakan dalam dua tahap, yaitu persiapan data dan pembuatan word cloud itu sediri.\nPersiapan data Sebagai ilustrasi kita coba buat word cloud dari naskah pidato pertama Presiden RI ke-7 sesaat setelah dilantik. Naskah tersebut didapat dari Tribun News, yang saya salin ke dalam file pidato-presiden.txt ini.\nPertama, kita harus membaca file teks dengan fungsi readLines():\ntext = readLines(\u0026#34;pidato-presiden.txt\u0026#34;) Sekarang kita mempunyai objek text yang merupakan character vector. Selanjutnya, kita modifikasi vektor text tersebut sehingga tiap elemen di dalamnya merupakan kata tunggal.\ntext = unlist(strsplit(text, \u0026#34;\\\\W+\u0026#34;)) R bersifat case-sensitive sehingga dalam pemrosesan data teks, akan lebih baik jika kita ubah text menjadi huruf kecil (lower-case) atau huruf besar (upper-case).\ntext = tolower(text) Terakhir, hitung frekuensi setiap kata muncul dalam naskah pidato.\ntext = data.frame(table(text)) Data frame text terdiri dari dua kolom, yaitu text atau daftar kata-kata tunggal serta Freq yang merupakan frekuensinya.\nMembuat word cloud Dalam R, word cloud dapat dibuat menggunakan package wordcloud yang ditulis oleh Ian Fellows. Instal package wordcloud dari repositori CRAN (apabila belum terinstal) lalu load ke dalam R session.\ninstall.packages(\u0026#34;wordcloud\u0026#34;, dependencies = T) library(wordcloud) Ok, everything is ready, and it\u0026rsquo;s time to generate a wordcloud!. Caranya mudah, cukup jalankan fungsi sederhana berikut\nwordcloud(text$text, text$Freq) dan hasilnya \u0026hellip;\n![Wordcloud]({{ site.url }}{{ site.baseurl }}/img/blog/2015-01-27-membuat-word-cloud-dengan-r/word-cloud-1.png)\nBagaimana, mudah bukan?\nTapi tunggu, dari word cloud di atas kita bisa melihat bahwa kata hubung dan kata bantu seperti \u0026ldquo;yang\u0026rdquo;, \u0026ldquo;dan\u0026rdquo;, \u0026ldquo;di\u0026rdquo;, \u0026ldquo;dalam\u0026rdquo;, \u0026ldquo;untuk\u0026rdquo; serta kata-kata lain yang tidak memberikan informasi penting justru tampak dominan. Kata-kata inilah yang biasa disebut sebagai stop-words. Dalam pengolahan data teks, kata-kata ini lazimnya diabaikan sehingga grafik yang dihasilkan lebih informatif. Dalam contoh ini, saya akan gunakan daftar stop-word bahasa Indonesia dari ranks.nl yang bisa diunduh di sini. Berikut adalah perintah untuk menghapus stop-words :\nstopw = readLines(\u0026#34;stopwords-id.txt\u0026#34;) text = text[!is.element(text$text, stopw),] Setelah stop-words dihapus, jalankan kembali fungsi wordcloud() dan ini kira-kira word cloud yang akan kita peroleh.\n![Wordcloud]({{ site.url }}{{ site.baseurl }}/img/blog/2015-01-27-membuat-word-cloud-dengan-r/word-cloud-2.png)\nBagaimana, terlihat lebih baik?\nSelanjutnya, kita bisa mencoba menambahkan parameter lain dalam fungsi wordcloud() untuk memperbaiki atau mempercantik tampilan. Misalnya,\nwordcloud(text$text, text$Freq, random.order=FALSE, rot.per=0.25 , colors=brewer.pal(8, \u0026#34;Dark2\u0026#34;)) Hasilnya \u0026hellip;\n![Wordcloud]({{ site.url }}{{ site.baseurl }}/img/blog/2015-01-27-membuat-word-cloud-dengan-r/word-cloud-3.png)\nUntuk mengetahui parameter apa saja yang bisa digunakan berikut penjelasannya, gunakan perintah ?wordcloud.\nJika kode R di atas digabung, kita hanya memerlukan tidak lebih dari 10 baris perintah untuk membuat wordcloud sederhana.\n# Menghitung frequensi per kata text = readLines(\u0026#34;pidato-presiden.txt\u0026#34;) text = unlist(strsplit(text, \u0026#34;\\\\W+\u0026#34;)) text = tolower(text) text = data.frame(table(text)) # Menghapus stop-words stopw = readLines(\u0026#34;stopwords-id.txt\u0026#34;) text = text[!is.element(text$text, stopw),] # Generate word-cloud wordcloud(text$text, text$Freq, random.order=FALSE, rot.per=0.25, colors=brewer.pal(8, \u0026#34;Dark2\u0026#34;)) Selamat mencoba :)\n","permalink":"/blog/membuat-word-cloud-dengan-r/","summary":"Bagaimana menampilkan data teks agar menarik sekaligus mudah dipahami? Tentu akan lebih baik menggunakan grafik dibandingkan dengan bentuk tabel yang berisi angka-angka, bukan? Ada berbagai macam grafik yang bisa digunakan. Untuk data teks, word cloud adalah salah satu pilihan.\nApa itu word cloud ? Word cloud (disebut juga text cloud atau tag cloud) merupakan salah satu metode untuk menampilkan data teks secara visual. Grafik ini populer dalam text mining karena mudah dipahami.","title":"Membuat Word Cloud dengan R"},{"content":"Pada artikel sebelumnya kita telah berdiskusi tentang fungsi-fungsi yang dapat digunakan untuk instal R package, baik instal dari dari file lokal menggunakan wizard, instal otomatis dari repositori CRAN dengan fungsi install.packages() maupun instal dari GitHub menggunakan fungsi install_github() dari package devtools.\nSetelah package terinstal, biasanya kita berkeinginan untuk mengelola R packages tersebut, misalnya untuk melihat package apa saja yang sudah diinstal, memeriksa apakan suatu package sudah terinstal, meng-uninstall package dan sebagainya. Berikut ini adalah beberapa fungsi untuk mengelola R package yang saya kutip dari R FAQ ini.\nMemeriksa package apa saja yang sudah terinstal Untuk melihat daftar package yang sudah terinstal gunakan fungsi installed.packages(). Fungsi tersebut menghasilkan sebuah matriks yang merinci package apa saja yang sudah terinstal pada R. Informasi yang terdapat pada matriks itu antara lain:\nPackage, nama package yang terinstal LibPath, library/folder di mana package terinstal Version, versi dari package Depends, dependencies Gunakan fungsi colnames() untuk menampilkan semua nama kolom dan nrow() untuk mengetahui jumlah package yang terinstal.\nx = installed.packages() colnames(x) nrow(x) Memeriksa apakah suatu package telah terinstal Terkadang kita ingin mengetahui apakah suatu package, misalnya twitteR, telah terinstal atau belum. Fungsi is.element() dapat digunakan untuk tujuan tersebut.\nis.element(\u0026#34;twitteR\u0026#34;, x[,1]) di mana x adalah output dari fungsi installed.packages(). Jika sudah terinstal, R console akan menjawab TRUE.\nMengetahui package apa saja yang tersedia Fungsi available.packages() menampilkan package apa saja yang tersedia. Fungsi tersebut menghasilkan sebuah matriks yang merinci semua package yang dapat kita instal dari repositori CRAN, dilengkapi dengan informasi pendukung seperti version, depends, dan lain-lain. Sesaat setelah saya jalankan fungsi berikut\nnrow(available.packages()) R console menampilkan angka 6147. Artinya, tersedia lebih dari 6 ribu package di repositori CRAN yang dapat kita download/instal. Fantastis.\nMenghapus package dari library Berkebalikan dengan install.packages(), fungsi remove.packages() berguna untuk menghapus (meng-uninstall) package dari library.\nMenampilkan informasi tentang suatu package Dokumentasi tentang sebuah package yang sudah terinstal dapat ditampilkan dengan fungsi help(). Misalnya:\nhelp(package=\u0026#34;twitteR\u0026#34;) akan menampilan deskripsi serta fungsi dan data yang tersedia pada package twitteR.\nAda fungsi lain yang terlewatkan? Yuk, kita diskusikan :)\n","permalink":"/blog/mengelola-r-package/","summary":"Pada artikel sebelumnya kita telah berdiskusi tentang fungsi-fungsi yang dapat digunakan untuk instal R package, baik instal dari dari file lokal menggunakan wizard, instal otomatis dari repositori CRAN dengan fungsi install.packages() maupun instal dari GitHub menggunakan fungsi install_github() dari package devtools.\nSetelah package terinstal, biasanya kita berkeinginan untuk mengelola R packages tersebut, misalnya untuk melihat package apa saja yang sudah diinstal, memeriksa apakan suatu package sudah terinstal, meng-uninstall package dan sebagainya.","title":"Mengelola R Package"},{"content":"Menggunakan paket twitteR, R dapat digunakan untuk mengambil informasi dari Twitter untuk keperluan analisis. Thanks to geoffjentry who created twitteR package and make it available for free. Agar R dan Twitter terhubung dengan baik, terlebih dahulu kita harus mendapatkan authentication. Berikut adalah proses twitter authentication dengan R:\nMendapatkan API key dan access token Kita harus mempunyai API key dan access token dari Twitter. Caranya sangat mudah. Kita hanya perlu membuat aplikasi pada Twitter.\nKunjungi https://apps.twitter.com dan login menggunakan akun Twitter Lalu Create New App Isi form berikut. Name dan Description bisa diisi apa saja. Tulis URL untuk pada kolom Website diawali http:// atau https://. Jika tidak punya website, isi dengan URL website apa saja yang penting valid. Untuk Callback URL biarkan saja kosong. {% include image url=\u0026quot;/img/blog/2015-01-17-twitter-authentication-dengan-r/create-new-app-twitter.png\u0026quot; alt=\u0026ldquo;create-new-app-twitter\u0026rdquo; caption=\u0026ldquo;Create an application\u0026rdquo; %}\nSetujui Developer Agreement dengan cek \u0026ldquo;Yes, I agree\u0026rdquo; Klik Create your Twitter application Pada tab Keys and Access Tokens, kita bisa melihat consumer key (API key) dan consumer secret (API secret) Untuk mendapatkan access tokens, klik tombol Create my access token Sekarang kita sudah memperoleh semua \u0026ldquo;kode rahasia\u0026rdquo; yang dapat digunakan untuk proses authentication, yaitu consumer key (API key), consumer secret (API secret), access token dan access token secret. {% include image url=\u0026quot;/img/blog/2015-01-17-twitter-authentication-dengan-r/ilustrasi-app-token.png\u0026quot; alt=\u0026ldquo;ilustrasi-app-token.png\u0026rdquo; caption=\u0026ldquo;Ilustrasi Twitter App yang menampilkan keys dan tokens (15 Jan 2019)\u0026rdquo; %}\n{% include textbox text=\u0026quot;UPDATE (16 Januari 2019): Pada Juli 2018, Twitter mengubah kebijakan terkait registrasi aplikasi baru. Kini, untuk membuat aplikasi harus menggunakan developer account. Saat melakukan registrasi, Twitter meminta kita untuk menjelaskan secara lebih detail hal-hal terkait dengan aplikasi. Selanjutnya Twitter akan meninjau, apakah aplikasi disetujui atau tidak. Kabar baiknya, aplikasi-aplikai yang didaftarkan sebelum diterapkannya kebijakan baru ini masih bisa digunakan. Setidaknya sampai hari ini. Info selengkapnya di sini.\u0026quot; %}\nInstall twitteR dari GitHub Instal versi terbaru paket twitteR dari GitHub:\ninstall.packages(c(\u0026#34;devtools\u0026#34;, \u0026#34;rjson\u0026#34;, \u0026#34;bit64\u0026#34;, \u0026#34;httr\u0026#34;)) Lalu, RESTART R session!\nlibrary(devtools) install_github(\u0026#34;twitteR\u0026#34;, username=\u0026#34;geoffjentry\u0026#34;) library(twitteR) Panduan lebih lengkap tentang bagaimana menginstal R package bisa dilihat pada artikel Menginstal R Package.\nTwitter Authentication dengan R Proses authentication dilakukan menggunakan fungsi setup_twitter_oauth() dengan format:\nsetup_twitter_oauth(api_key, api_secret, access_token, access_token_secret) Gunakan key dan token yang diperoleh pada langkah sebelumnya.\nKetika fungsi dijalankan, R console akan menanyakan: Use a local file to cache OAuth access credentials between R sessions?. Ketik 1 atau 2.\nSelamat, proses authentication sudah berhasil dan selanjutnya kita bisa mengekstrak data dari Twitter, misalnya mencari tweet terkini yang mengandung kata \u0026lsquo;bogor\u0026rsquo;.\nsearchTwitter(\u0026#34;bogor\u0026#34;) Oiya, sebagai catatan, kita harus melakukan proses authentication di atas pada setiap session R.\nSumber: ThinkToStart dan GitHub\n","permalink":"/blog/twitter-authentication-dengan-r/","summary":"Menggunakan paket twitteR, R dapat digunakan untuk mengambil informasi dari Twitter untuk keperluan analisis. Thanks to geoffjentry who created twitteR package and make it available for free. Agar R dan Twitter terhubung dengan baik, terlebih dahulu kita harus mendapatkan authentication. Berikut adalah proses twitter authentication dengan R:\nMendapatkan API key dan access token Kita harus mempunyai API key dan access token dari Twitter. Caranya sangat mudah. Kita hanya perlu membuat aplikasi pada Twitter.","title":"Twitter Authentication dengan R"},{"content":"Salah satu kenapa R menjadi sangat popular adalah ketersediaan paket/packages (kumpulan fungsi, data dan kode) R. Hingga hari ini, ada lebih dari 6 ribu paket R ada di repository CRAN. Belum termasuk paket yang disediakan sumber lain. Jumlah paket tersebut terus tumbuh dari hari-ke-hari secara eksponensial.\nPada saat instal R untuk pertama kali, hanya beberapa paket yang ikut terinstal secara otomatis. Sementara paket lainnya harus kita instal secara manual untuk bisa digunakan.\nMenginstal R package dari lokal Dari halaman CRAN, pilih paket yang diinginkan, misalnya paket car Download package source (file .zip). Dalam contoh ini adalah file \u0026ldquo;car_2.0-22.zip\u0026rdquo;. Pada RGUI, Klik menu Packages, lalu pilih Install package(s) from local zip files... Pilih file .zip yang telah kita download Jika berhasil, R console akan memberi pesan package 'car' successfully unpacked and MD5 sums checked. Menginstal R package langsung dari CRAN repository Ketika sedang terhubung dengan internet, menginstal paket dapat langsung dilakukan dari CRAN repository. Caranya sangat sederhanya, yaitu dengan menggunakan fungsi :\ninstall.packages(pkgs) pkgs adalah nama paket yang akan diinstal, bisa satu atau lebih (nama paket bersifat case-sensitive). Misalnya untuk menginstal paket car, jalankan perintah berikut pada R console :\ninstall.packages(\u0026#34;car\u0026#34;) Lalu pilih CRAN mirror, misalnya \u0026ldquo;Indonesia (Jakarta)\u0026rdquo;. Sama seperti menginstal paket dari file lokal, akan muncul pesan package 'car' successfully unpacked and MD5 sums checked pada R console.\nUntuk menginstal dua atau lebih paket dalam satu perintah, misalnya paket car dan ggplot2, modifikasi fungsi install.packages() menjadi :\ninstall.packages(c(\u0026#34;car\u0026#34;, \u0026#34;ggplot2\u0026#34;)) Kadang kala, paket yang kita instal mempunyai ketergantungan (misalnya memanggil fungsi) terhadap paket lain. Tentu saja paket lain tersebut harus kita instal. Dengan menambahkan opsi dependencies = TRUE pada fungsi install.packages() maka R akan menginstal semua paket yang dibutuhkan. (KOREKSI dari Mas Suharto pada comment di bawah, bahwa \u0026ldquo;Secara default, tanpa dependencies=TRUE, install.packages juga meng-install paket lain yang dibutuhkan. Namun, paket yang termasuk “Suggests” (artinya paket itu digunakan, tetapi tanpa paket itu pun bisa jalan) tidak ikut di-install\u0026rdquo;).\ninstall.packages(c(\u0026#34;car\u0026#34;, \u0026#34;ggplot2\u0026#34;), dependencies=TRUE) Pada R console akan muncul info : also installing the dependencies ‘effects’, ‘minqa’, ‘nloptr’, .....\nSetelah proses instalasi selesai dilakukan, load (muat) paket ke dalam R session dengan fungsi library(), misalnya :\nlibrary(car) Dan \u0026hellip;. paket car siap digunakan. Sangat mudah bukan ?\nMenginstal R package dari GitHub Selain dari CRAN, kita juga bisa menginstal paket (pada umumnya versi developer) dari GitHub menggunakan fungsi install_github(). Fungsi tersebut ada pada paket devtools. Berikut tahapan instal paket dari GitHub:\nInstal paket devtools dari CRAN (jika belum terinstal), dan load ke dalam R session\ninstall.packages(\u0026#34;devtools\u0026#34;) library(devtools) Jalankan perintah install_github(package, username) atau install_github(username/package) di mana package adalah nama paket dan username adalah user name. Misalnya :\ninstall_github(\u0026#34;wch/ggplot2\u0026#34;) Atau\ninstall_github(\u0026#34;ggplot2\u0026#34;, \u0026#34;wch\u0026#34;) Atau, untuk instal banyak paket sekaligus\ninstall_github(c(\u0026#34;geoffjentry/twitteR\u0026#34;, \u0026#34;wch/ggplot2\u0026#34;)) Selamat mencoba \u0026hellip; :)\n","permalink":"/blog/menginstal-r-package/","summary":"Salah satu kenapa R menjadi sangat popular adalah ketersediaan paket/packages (kumpulan fungsi, data dan kode) R. Hingga hari ini, ada lebih dari 6 ribu paket R ada di repository CRAN. Belum termasuk paket yang disediakan sumber lain. Jumlah paket tersebut terus tumbuh dari hari-ke-hari secara eksponensial.\nPada saat instal R untuk pertama kali, hanya beberapa paket yang ikut terinstal secara otomatis. Sementara paket lainnya harus kita instal secara manual untuk bisa digunakan.","title":"Menginstal R Package"},{"content":"Markdown adalah tools konversi text-to-HTML. Dengan Markdown, kita dapat menulis sebuah teks dengan mudah dan mengkonversinya menjadi HTML/XHTML. Markdown dibuat oleh John Gruber sejak tahun 2004 dan terus dikembangkan hingga sekarang.\nMarkdown merupakan alternatif untuk menulis konten untuk web maupun blog tanpa menuliskan tag HTML, yaitu dengan hanya menuliskan teks biasa ditambah simbol-simbol yang umum digunakan seperti asterisks (*), undescore (_), tanda lebih kecil/besar (\u0026lt; \u0026gt;), dan lain-lain. Dengan demikian selain lebih sederhana, Markdown sangat mudah ditulis dan juga dibaca. Untuk menulis teks dalam format italic (cetak miring), misalnya, kita hanya perlu menggunakan asterisks (*), tidak lagi menggunakan tag HTML \u0026lt;i\u0026gt;.\n![markdown]({{ site.url }}{{ site.baseurl }}/img/blog/2015-01-11-format-teks-dengan-markdown/markdown.png)\nKarena sangat mudah digunakan, Markdown menjadi salah satu standar dalam penulisan dokumen untuk akademik, scientist dan lainnya. Website seperti GitHub, reddit, stackoverflow dan SourceForge telah menggunakan Markdown untuk formatting konten maupun komentar.\nMarkdown dapat digunakan pada Wordpress dengan terlebih dahulu menginstal dan mengaktifkan plugin WP-Markdown atau JetPack.\nBagaimana menggunakan Markdown? Berikut adalah contoh bagaimana menata format teks dengan Markdown.\nHeader # Header 1\r## Header 2\r...\r###### Header 6\rAtau\rAlternatif Header 1\r===================\rAlternatif Header 2\r-------------------\rOutput:\nHeader 1 Header 2 \u0026hellip;\nHeader 6 Atau\nAlternatif Header 1 Alternatif Header 2 Emphasis Miring atau italic : *asterisks* atau _underscores_.\rTebal atau bold : double **asterisks** atau __underscores__.\rMiring dan tebal : **asterisks dan _underscores_**.\rOutput:\nMiring atau italic : asterisks atau underscores. Tebal atau bold : double asterisks atau underscores. Miring dan tebal : asterisks dan underscores.\nCode Untuk code dalam teks (inline), gunakan single-backtick ```, misalnya:\nIni huruf `monospace`\rOutput:\nIni huruf monospace\nSedangkan jika terdiri dari beberapa baris, gunakan triple-backticks, misalnya:\n```\rinstall.packages(\u0026quot;twitteR\u0026quot;)\rlibrary(twitteR)\r```\rOutput:\ninstall.packages(\u0026quot;twitteR\u0026quot;)\rlibrary(twitteR)\rAtau beri empat spasi sebelum kode:\ninstall.packages(\u0026#34;twitteR\u0026#34;)\rlibrary(twitteR) List 1. Pertama\r1. Sub-item\r2. Sub-item lagi.\r2. Kedua\r* Bisa dengan asteriks.\r- Bisa juga dengan minus.\r+ Atau dengan plus.\r3. Ketiga\rOutput:\nPertama Sub-item Sub-item lagi. Kedua Bisa dengan asteriks. Bisa juga dengan minus. Atau dengan plus. Ketiga Quote \u0026gt; \u0026quot;Dan sebaik-baik manusia adalah orang yang paling bermanfaat bagi manusia.\u0026quot; *(HR. Thabrani dan Daruquthni)*\rOutput:\nDan sebaik-baik manusia adalah orang yang paling bermanfaat bagi manusia. (HR. Thabrani dan Daruquthni)\nLink \u0026lt;https://www.google.com\u0026gt;\r[Google](https://www.google.com)\r[Google](https://www.google.com \u0026quot;Google's Homepage\u0026quot;)\rOutput:\nhttps://www.google.com Google Google\nImage ![Logo R](www.r-project.org/Rlogo.jpg)\rOutput:\nSintaks lengkapnya bisa diperoleh di daringfireball.net. Contoh penggunaan Markdown bisa dilihat pada halaman GitHub ini dan ini, atau Googling. Selamat mencoba.\nR Markdown — Dynamic Documents for R R Markdown adalah paket R yang mengkombinasikan sintaks Markdown dengan kode R untuk membuat dokumen, presentasi dan laporan dengan R.\n![markdown-chunk]({{ site.url }}{{ site.baseurl }}/img/blog/2015-01-11-format-teks-dengan-markdown/markdownChunk.png)\nTunggu tutorial bagimana menggunakan R Markdown. Karena, honestly, saya juga belum pernah menggunakannya. :)\n","permalink":"/blog/format-teks-dengan-markdown/","summary":"Markdown adalah tools konversi text-to-HTML. Dengan Markdown, kita dapat menulis sebuah teks dengan mudah dan mengkonversinya menjadi HTML/XHTML. Markdown dibuat oleh John Gruber sejak tahun 2004 dan terus dikembangkan hingga sekarang.\nMarkdown merupakan alternatif untuk menulis konten untuk web maupun blog tanpa menuliskan tag HTML, yaitu dengan hanya menuliskan teks biasa ditambah simbol-simbol yang umum digunakan seperti asterisks (*), undescore (_), tanda lebih kecil/besar (\u0026lt; \u0026gt;), dan lain-lain. Dengan demikian selain lebih sederhana, Markdown sangat mudah ditulis dan juga dibaca.","title":"Format Teks dengan Markdown"},{"content":"Sedang belajar R? Lupakan cara tradisional! Kini kita dapat belajar R dengan swirl. Ya, swirl adalah R package untuk belajar statistika sekaligus R. swirl mengubah R console menjadi sarana belajar yang interaktif. Menggunakan swirl, kita dapat belajar data science, statistika dan R secara mandiri, mudah dan menyenangkan. Pengguna akan mendapatkan umpan-balik sesaat setelah mamasukan kode-kode R. Informasi detail mengenai swirl dapat diperoleh di swirlstats.com atau di halaman Github ini.\nMenginstal swirl Cara paling mudah untuk menginstal swirl adalah melalui CRAN. Jalankan perintah berikut pada R console :\ninstall.packages(\u0026#34;swirl\u0026#34;) Atau, jika ingin menginstal versi developer-nya:\ninstall.packages(\u0026#34;devtools\u0026#34;) library(devtools) devtools::install_github(\u0026#34;swirldev/swirl\u0026#34;) Panduan lebih lengkap tentang bagaimana menginstal R package bisa dilihat pada artikel Menginstal R Package.\nMenginstal materi belajar Materi belajar pada swirl harus diinstal secara terpisah. Caranya:\nlibrary(swirl) install_from_swirl(\u0026#34;Nama Materi\u0026#34;) swirl() Ganti Nama Materi dengan materi yang diinginkan. Sebagai contoh, install_from_swirl(\u0026quot;R Programming\u0026quot;) akan menginstal materi untuk R Programming (nama materi case-sensitive).\nDaftar materi yang disediakan Berikut adalah daftar materi yang disediakan oleh swirl:\nBeginner R Programming: dasar-dasar pemromgraman dalam R R Programming Alt: sama seperti R Programming, tapi ada sedikit modifikasi Data Analysis: Dasar-dasar analisis data Mathematical Biostatistics Boot Camp: t-test dan sampling Open Intro: Pengenalan statistika, analisis data dan visualisasi Intermediate Regression Models: Model regresi menggunakan R Getting and Cleaning Data: Data cleansing Advanced Statistical Inference: Konsep dasar peluang (probability), pengujian hipotesis, selang kepercayaan (confidence intervals) dan nilai-p (p-value). Selengkapnya bisa lihat repo Github ini. Selamat mencoba :)\n","permalink":"/blog/swirl-belajar-r-dengan-r/","summary":"Sedang belajar R? Lupakan cara tradisional! Kini kita dapat belajar R dengan swirl. Ya, swirl adalah R package untuk belajar statistika sekaligus R. swirl mengubah R console menjadi sarana belajar yang interaktif. Menggunakan swirl, kita dapat belajar data science, statistika dan R secara mandiri, mudah dan menyenangkan. Pengguna akan mendapatkan umpan-balik sesaat setelah mamasukan kode-kode R. Informasi detail mengenai swirl dapat diperoleh di swirlstats.com atau di halaman Github ini.\nMenginstal swirl Cara paling mudah untuk menginstal swirl adalah melalui CRAN.","title":"swirl: Belajar R, dengan R"},{"content":"Salah satu nilai plus Jekyll adalah fleksibilitas untuk mengubah theme/tema. Meskipun merupakan web statis, nyatanya di jagad internet banyak sekali theme yang bisa digunakan untuk berbagai keperluan, mulai dari halaman biodata sampai web ecommerce. Tidak percaya? Silakan Googling sendiri. Hanya saja, mengganti theme sebuah blog berbasiskan Jekyll ternyata tidak semudah mengganti theme pada Wordpress yang cukup dilakukan dengan beberapa klik saja. Ada \u0026ldquo;keruwetan\u0026rdquo; sendiri. Setidaknya itu yang sama alami dalam beberapa hari terakhir saat mengganti theme blog NURANDI.id; yang awalnya beautiful-jekyll saya ganti dengan Pixyll. Sebenarnya kedua theme itu hampir serupa. Sama-sama theme minimalis yang fokus pada readability. Tapi saya merasa Pixyll ini lebih fresh. Baiklah!\n{% include image url=\u0026rsquo;/img/blog/2019-12-03-mengganti-theme-jekyll-pada-github/nurandi-id-old.jpg\u0026rsquo; caption=\u0026ldquo;Tampilan lama blog NURANDI.id dengan theme beautiful-jekyll\u0026rdquo; %}\nBlog NURANDI.id sebenarnya merupakan sebuah Github page. Seluruh tulisan, kode, theme dan material lain untuk membangun blog saya hosting di GitHub. Selain sengaja menjadikan blog bersifat open source, GitHub sebagai layanan version control memberikan keuntungan karena saya bisa mengetahui seluruh perubahan yang terjadi pada blog saya. Sebenarnya mudah saja untuk mengganti theme dengan lima langkah berikut:\nclone repo blog, download theme Pixyll, ganti theme sebelumnya dengan theme dari Pixyll, atur file _config.yml dan file lainnya, push back ke Github. Selesai. Hanya saja, cara ini tidak hanya membuat saya kehilangan version history dari Pixyll, tetapi juga \u0026ldquo;terputus\u0026rdquo; dari \u0026ldquo;upstream repository\u0026rdquo;-nya sehingga sulit mendapatkan update dan menghilangkan kesempatan untuk berkolaborasi. Karena itulah, cara ini tidak saya lakukan karena kedua hal ini bertolak belakang dengan alasan saya berpindah dari Wordpress ke GitHub/Jekyll. Itu yang membuat proses ini sedikit \u0026ldquo;ruwet\u0026rdquo;.\nSebagai pengguna Git pemula, saya beruntung menemukan artikel dari Enda dan sebuah jawaban dari Daniel Pelsmaeker di Stackoverflow yang secara ringkas menjelaskan cara mengganti theme Jekyll di GitHub sekaligus secara tidak langsung mengajari saya tentang branching. Dengan menggunakan Git Bash, ini tahapannya:\n{% include image url=\u0026rsquo;/img/blog/2019-12-03-mengganti-theme-jekyll-pada-github/nurandi-id-new.jpg\u0026rsquo; caption=\u0026ldquo;Tampilan baru blog NURANDI.id dengan theme Pixyll yang lebih fresh :)\u0026rdquo; %}\nClone repositori blog ke lokal\ngit clone https://github.com/nurandi/nurandi.github.io.git\rcd nurandi.github.io Buat orphan branch, misalnya newtheme, pastikan kosong\ngit checkout --orphan newtheme\rgit rm -rf .\rgit clean -dfx Pull theme dari upstream remote repository ke branch tersebut. Saya pull master branch dari theme Pixyll\ngit remote add upstream https://github.com/johnotander/pixyll.git\rgit fetch upstream\rgit pull upstream master Instal Gems yang diperlukan, lalu jalankan Jekyll\nbundle exec jekyll serve Merge post, config, dan lain-lain. Kita dapat menggunakan perintah git checkout untuk meng-copy folder/file dari theme sebelumnya, misalnya\ngit checkout master -- _posts Sebagai alternatif, copy dengan nama baru, lalu merge secara manual\ngit show master:_config.yml \u0026gt; _config.yml.old Restore apabila ada file/folder yang tertimpa\ngit checkout upstream/master -- about.md Beberapa file/folder yang saya copy, merge, modifikasi dan hapus adalah:\nArtikel di folder _posts Image di folder img File konfigurasi _config.yml File CNAME File Gemfile File favicon File/folder penunjang lain seperti _Rmd, _src, dll Jangan lupa commit\ngit add .\rgit commit -m \u0026#34;switch theme\u0026#34; Jalankan kembali Jekyll untuk melihat perubahan sesuai dengan yang diinginkan\nGanti seluruh konten pada branch master dengan newtheme\ngit checkout newtheme\rgit merge -s ours master --allow-unrelated-histories\rgit checkout master\rgit merge newtheme Push ke remote repository\ngit push Hapus branch newtheme untuk menghilangkan jejak\ngit branch -d newtheme Selesai!\nJika suatu saat ingin meng-update theme, termasuk perubahan pada upstream, tinggal jalankan\ngit pull upstream master Sesuaikan jika ada conflict .\n{% include image url=\u0026rsquo;/img/blog/2019-12-03-mengganti-theme-jekyll-pada-github/git-contributor.jpg\u0026rsquo; caption=\u0026ldquo;Salah satu file dalam theme, terlihat banyak sekali kontributor yang terlibat\u0026rdquo; %}\n{% include image url=\u0026rsquo;/img/blog/2019-12-03-mengganti-theme-jekyll-pada-github/git-history.jpg\u0026rsquo; caption=\u0026quot;History perubahan dapat dilihat. Inilah kenapa saya membiasakan untuk menggunakan Git/GitHub\u0026quot; %}\nSemoga bermanfaat :)\n","permalink":"/blog/mengganti-theme-jekyll-pada-github/","summary":"Salah satu nilai plus Jekyll adalah fleksibilitas untuk mengubah theme/tema. Meskipun merupakan web statis, nyatanya di jagad internet banyak sekali theme yang bisa digunakan untuk berbagai keperluan, mulai dari halaman biodata sampai web ecommerce. Tidak percaya? Silakan Googling sendiri. Hanya saja, mengganti theme sebuah blog berbasiskan Jekyll ternyata tidak semudah mengganti theme pada Wordpress yang cukup dilakukan dengan beberapa klik saja. Ada \u0026ldquo;keruwetan\u0026rdquo; sendiri. Setidaknya itu yang sama alami dalam beberapa hari terakhir saat mengganti theme blog NURANDI.","title":"Mengganti Theme Jekyll pada GitHub"},{"content":"Sekitar empat tahun lalu, saya menulis artikel dengan judul yang hampir sama persis: twitteR: Crawling Data Twitter Menggunakan R. Pada saat itu, cara paling mudah untuk mendapatkan (crawling) data dari Twitter dengan R adalah menggunakan package twitteR. Sayangnya pada pertengahan 2016, Jeff Gentry, sang pengembang, menghentikan pengembangan dan update/maintenance terhadap package tersebut. Meskipun package twitteR masih bisa digunakan (setidaknya sampai saat ini), Mr. Jeff merekomendasikan untuk beralih menggunakan package lain yang tidak kalah kerennya, yaitu rtweet.\n{% include image url=\u0026quot;/img/blog/2019-01-15-rtweet-crawling-data-twitter-menggunakan-r/twitter-techgladscom.png\u0026quot; alt=\u0026ldquo;twitter-techgladscom.png\u0026rdquo; caption=\u0026ldquo;Twitter. Kredit: techglads.com\u0026rdquo; %}\nrtweet dikembangkan oleh Michael W. Kearney. Versi pertama dirilis pada Agustus 2018, atau hampir bersamaan dengan pengumuman penghentian pengembangan twitteR. Sesuai dengan deskripsinya, rtweet berfungsi untuk mengakses API Twitter melalui R. Jika twitteR hanya mampu digunakan untuk berinteraksi dengan REST API (untuk mencari \u0026ldquo;data\u0026rdquo; historis atau yang sudah lampau), rtweet ini bisa juga digunakan untuk mengakses stream API (live/realtime). Pada artikel ini kita bahas untuk REST API dulu ya.\nInstalasi Ada dua cara, yaitu install dari CRAN (untuk versi rilis terkini) dan dari Github (untuk versi development/pengembangan).\nOpsi 1: dari CRAN {% highlight r %} install.packages(\u0026ldquo;rtweet\u0026rdquo;) {% endhighlight %}\nOpsi 2: dari Github Note: install dari Github memerlukan package devtools\n{% highlight r %} install.packages(\u0026ldquo;devtools\u0026rdquo;) library(devtools) {% endhighlight %}\n{% highlight r %} install_github(\u0026ldquo;mkearney/rtweet\u0026rdquo;) {% endhighlight %}\nSetelah terinstal, load package rtweet\n{% highlight r %} library(rtweet) {% endhighlight %}\nPelajari lebih lengkap tentang instalasi package R melalui artikel Menginstal R Package.\nAPI Authorization Untuk mengakses API Twitter diperlukan akun Twitter, aplikasi (application) dan token akses (access token). Silakan pelajari langkah-langkah membuat aplikasi dan mendapatkan token akses pada artikel Twitter Authentication dengan R.\n{% include image url=\u0026quot;/img/blog/2019-01-15-rtweet-crawling-data-twitter-menggunakan-r/ilustrasi-app-token.png\u0026quot; alt=\u0026ldquo;ilustrasi-app-token.png\u0026rdquo; caption=\u0026ldquo;Ilustrasi Twitter App yang menampilkan keys dan tokens\u0026rdquo; %}\nNote: Pada Juli 2018, Twitter mengubah kebijakan terkait registrasi aplikasi baru. Kini, untuk membuat aplikasi harus menggunakan developer account. Saat melakukan registrasi, Twitter meminta kita untuk menjelaskan secara lebih detail hal-hal terkait dengan aplikasi. Selanjutnya Twitter akan meninjau, apakah aplikasi disetujui atau tidak. Kabar baiknya, aplikasi-aplikai yang didaftarkan sebelum diterapkannya kebijakan baru ini masih bisa digunakan. Setidaknya sampai hari ini. Info selengkapnya di sini.\nSetelah membuat aplikasi, proses selanjutnya adalah otentikasi (authentication) agar R melalui rtweet bisa berinteraksi dengan API Twitter. Proses ini ada dua opsi, yaitu (1) melalui browser dan (2) dengan access token. Keduanya dengan menggunakan fungsi create_token(). Silakan pilih salah satu.\nOpsi 1: Otentikasi melalui browser Opsi ini membutuhkan:\nConsumer API key Consumer API secret key {% highlight r %} token \u0026lt;- create_token( consumer_key = \u0026ldquo;XXXXXk4gFgjuI6hx05zwaGh0Q\u0026rdquo;, consumer_secret = \u0026ldquo;XXXXXCPPWEBJhYS4Z7rDVGZt3y1dkVehTnSe7wsM0NKVWBDLoV\u0026rdquo;) {% endhighlight %}\nR otomatis akan membuka browser, meminta login ke Twitter dan menampilkan pesan:\nAuthentication complete. Please close this page and return to R. Ini berarti otentikasi berhasil.\nOpsi 2: Otentikasi dengan access token/secret Selain consumer API dan API secret key, opsi ini juga membutuhkan:\nAccess token Access token secret {% highlight r %} token \u0026lt;- create_token( consumer_key = \u0026ldquo;XXXXXk4gFgjuI6hx05zwaGh0Q\u0026rdquo;, consumer_secret = \u0026ldquo;XXXXXCPPWEBJhYS4Z7rDVGZt3y1dkVehTnSe7wsM0NKVWBDLoV\u0026rdquo;, access_token = \u0026ldquo;XXXXX937-XXXXXu6x7wR70mUAWc1BCc7gJIOdfugps6iFgU6GO\u0026rdquo;, access_secret = \u0026ldquo;XXXXXkUqEsfnfsy31GSLIEyaiDLB0UC2rw8EP1gNaLTc7\u0026rdquo;) {% endhighlight %}\nJika tidak muncul error, berarti proses otentikasi sukses.\nNote: Consumer API key, consumer API secret key, access token dan access token secret di atas hanya contoh, silakan ganti dengan nilai yang sesuai.\nCrawling Data Twitter Setelah proses otentikasi berhasil, kita siap untuk \u0026ldquo;menambang\u0026rdquo; data (crawling) dari Twitter. Untuk kepeluan ini, rtweet mengemas berbagai fungsi yang cukup lengkap, di antaranya:\nsearch_tweets() : mencari tweet dengan kata kunci tertentu lookup_users() : menampilkan data detail dari satu atau lebih user(s) get_timelines() : menampilkan status/tweet yang pernah diposting oleh user tertentu aka timeline get_followers() : menampilkan list followers dari user tertentu get_friends() : menampilkan list fiends/followings atau yang di-follow user tentu dan masih banyak yang lain seperti untuk menampilkan retweet, siapa yang me-retweet, mendapatkan list favorite, menampilkan trending topics, cleansing tweet, dan juga ekspor data ke file csv. search_tweets() Mencari tweet yang memuat kata kunci tertentu. Secara default, dalam sekali dijalankan akan memberikan MAKSIMAL 18.000 tweets, yang merupakan sampel dari historis tujuh hari terakhir. Bagaimana kalau ingin lebih dari 18 ribu atau lebih dari tujuh hari? Salah satu caranya dengan membuat akun premium atau entreprise. Lebih lengkap tentang ketentuan ini bisa dibaca di sini.\n{% include image url=\u0026quot;/img/blog/2019-01-15-rtweet-crawling-data-twitter-menggunakan-r/search-tweet.png\u0026quot; alt=\u0026ldquo;search-tweet.png\u0026rdquo; caption=\u0026ldquo;Ilustrasi search pada Twitter\u0026rdquo; %}\nContoh: mencari (hingga) 1.000 tweets yang memuat kata kunci \u0026ldquo;bogor\u0026rdquo;\n{% highlight r %} tweet \u0026lt;- search_tweets(q = \u0026ldquo;kota bogor\u0026rdquo;, n = 1000) {% endhighlight %}\nObjek tweet merupakan data frame/tibble dengan lebih dari 80 variabel/kolom. Silakan tampilkan dengan perintah:\n{% highlight r %} colnames(tweet) {% endhighlight %}\nKita lihat tiga kolom di antaranya:\n{% highlight r %} tweet[,c(\u0026ldquo;created_at\u0026rdquo;, \u0026ldquo;screen_name\u0026rdquo;, \u0026ldquo;text\u0026rdquo;)] {% endhighlight %}\n{% highlight text %}\n# A tibble: 994 x 3 created_at screen_name text 1 2019-01-16 12:35:57 hasnahahahah~ @CommuterLine kereta terakhir dr jkt ~ 2 2019-01-16 12:35:20 iffa_retno69 \u0026ldquo;#dadakan #padangsidempuan #sidikalan~ 3 2019-01-13 19:09:55 iffa_retno69 \u0026ldquo;#padangsidempuan #sidikalang #tebing~ 4 2019-01-16 12:11:59 terrotouli Kekurangan dari pembangunan infrastru~ 5 2019-01-16 12:10:53 aininur56 5. Sekretaris PCNU Kota Bogor ini men~ 6 2019-01-16 12:07:08 CommuterLine @imbecillic Selamat malam, untuk pemb~ 7 2019-01-13 14:36:10 CommuterLine #InfoLintas : KA 1460 (Jakarta Kota-B~ 8 2019-01-13 12:46:36 CommuterLine @itsmeanggii Cikarang-Jakarta Kota te~ 9 2019-01-15 13:34:21 CommuterLine @ditakswn Selamat malam. Kami informa~ 10 2019-01-15 16:41:12 CommuterLine @CahyoWarih Selamat malam. Dapat kami~ # \u0026hellip; with 984 more rows {% endhighlight %}\nKeyword/query dapat berupa satu atau beberapa kata, namun hindari keyword yang kompleks. Menurut Twitter, query sebaiknya tidak lebih dari 10 kata. Berikut contoh cara penulisan keyword:\nQuery Untuk mencari tweet yang mengandung: \u0026quot;bogor\u0026quot; kata \u0026ldquo;bogor\u0026rdquo; \u0026quot;kota bogor\u0026quot; kata \u0026ldquo;kota\u0026rdquo; dan kata \u0026ldquo;bogor\u0026rdquo; (tidak memperhatikan urutan) \u0026quot;\\\u0026quot;kota bogor\\\u0026quot;\u0026quot; frase \u0026ldquo;kota bogor\u0026rdquo; \u0026quot;kota OR bogor\u0026quot; kata \u0026ldquo;kota\u0026rdquo; atau kata \u0026ldquo;bogor\u0026rdquo; atau keduanya \u0026quot;kota -bogor\u0026quot; kata \u0026ldquo;kota\u0026rdquo; tapi tidak memuat kata \u0026ldquo;bogor\u0026rdquo; \u0026quot;#bogor\u0026quot; hashtag \u0026ldquo;bogor\u0026rdquo; \u0026quot;@bogor\u0026quot; mention \u0026ldquo;bogor\u0026rdquo; get_timelines() Menampilkan timeline atau status/tweet terbaru yang pernah di-posting oleh satu atau beberapa user(s). Setiap user akan ditampilkan hingga maksimal 3.200 tweet.\nContoh: Menapilkan timeline dari \u0026ldquo;nurandi\u0026rdquo;\n{% highlight r %} timeline \u0026lt;- get_timeline(\u0026ldquo;nurandi\u0026rdquo;) {% endhighlight %}\nObjek yang dihasilkan berupa data frame/tibble dengan lebih dari 80 kolom.\n{% highlight r %} timeline[,c(\u0026ldquo;created_at\u0026rdquo;, \u0026ldquo;source\u0026rdquo;, \u0026ldquo;text\u0026rdquo;)] {% endhighlight %}\n{% highlight text %}\n# A tibble: 100 x 3 created_at source text 1 2019-01-16 03:23:37 Twitter Web ~ https://t.co/b5KGxX56L5 2 2019-01-07 04:51:17 IFTTT New blog article: Apa Itu Jekyll dan ~ 3 2018-12-13 23:53:31 Twitter for ~ \u0026ldquo;Semoga kita bukan termasuk orang yan~ 4 2018-09-18 12:47:30 Twitter for ~ aku kalo ke ATM lebih takut keliatan ~ 5 2018-08-17 01:37:24 Twitter Web ~ \u0026ldquo;@Telkomsel Hi, saya berlangganan pak~ 6 2018-07-05 01:55:25 Twitter for ~ @IndonesiaGaruda halo, GA-824 CGK-SIN~ 7 2018-06-02 16:51:35 Twitter for ~ \u0026ldquo;English: i know i supposed to meet y~ 8 2018-04-23 04:54:58 Twitter for ~ @imigrasi_jakbar Min, saya sudah daft~ 9 2018-04-04 08:37:53 Twitter for ~ @TokopediaCare verifikasi pembayatan ~ 10 2018-03-13 04:42:15 Twitter for ~ @BPJSTKinfo Terima kasih infonya. BPJ~ # \u0026hellip; with 90 more rows {% endhighlight %}\nlookup_users() Menampilkan data detail dari satu atau lebih akun/user(s).\nContoh: Menampilkan detail dari \u0026ldquo;nurandi\u0026rdquo;\n{% highlight r %} user \u0026lt;- lookup_users(\u0026ldquo;nurandi\u0026rdquo;) {% endhighlight %}\nObjek yang dihasilkan juga merupakan data frame/tibble dengan lebih dari 80 kolom.\n{% highlight r %} user[,c(\u0026ldquo;created_at\u0026rdquo;, \u0026ldquo;screen_name\u0026rdquo;, \u0026ldquo;name\u0026rdquo;, \u0026ldquo;location\u0026rdquo;, \u0026ldquo;description\u0026rdquo;)] {% endhighlight %}\n{% highlight text %}\n# A tibble: 1 x 5 created_at screen_name name location description 1 2019-01-16 03:23:37 nurandi Nur Andi S~ Jakarta/Bog~ Aspiring Data S~ {% endhighlight %}\nUntuk lookup beberapa user(s), input harus berupa vector. Misal:\n{% highlight r %} users \u0026lt;- lookup_users(c(\u0026ldquo;nurandi\u0026rdquo;, \u0026ldquo;jokowi\u0026rdquo;, \u0026ldquo;billgates\u0026rdquo;, \u0026ldquo;mosalah\u0026rdquo;)) {% endhighlight %}\n{% highlight r %} users[,c(\u0026ldquo;created_at\u0026rdquo;, \u0026ldquo;screen_name\u0026rdquo;, \u0026ldquo;name\u0026rdquo;, \u0026ldquo;location\u0026rdquo;, \u0026ldquo;description\u0026rdquo;)] {% endhighlight %}\n{% highlight text %}\n# A tibble: 4 x 5 created_at screen_name name location description 1 2019-01-16 03:23:37 nurandi Nur And~ Jakarta/B~ Aspiring Data Scient~ 2 2019-01-16 10:10:08 jokowi Joko Wi~ Jakarta \u0026ldquo;Akun Twitter resmi ~ 3 2019-01-15 17:23:00 BillGates Bill Ga~ Seattle, ~ Sharing things I\u0026rsquo;m l~ 4 2019-01-09 08:16:38 MoSalah Mohamed~ Liverpool~ Footballer for Liver~ {% endhighlight %}\nget_followers() dan get_friends() Menampilkan list dari followers (yang mem-follow) dan list dari followings/friends (yang di-follow) oleh akun/user tertentu.\nContoh: Menampilkan list followers dari \u0026ldquo;nurandi\u0026rdquo;\n{% highlight r %} followers \u0026lt;- get_followers(\u0026ldquo;nurandi\u0026rdquo;) followings \u0026lt;- get_friends(\u0026ldquo;nurandi\u0026rdquo;) {% endhighlight %}\nOutput yang dihasilkan berupa tibble dari user_id.\n{% highlight r %} followers {% endhighlight %}\n{% highlight text %}\n# A tibble: 255 x 1 user_id 1 743414321514897408 2 1042477396547395585 3 1049626193857732611 4 49285223 5 1018277822542929920 6 1039338205743538176 7 1027183219244847110 8 73331490 9 58994539 10 986940727077699585 # \u0026hellip; with 245 more rows {% endhighlight %}\n{% highlight r %} followings {% endhighlight %}\n{% highlight text %}\n# A tibble: 325 x 2 user user_id 1 nurandi 59106338 2 nurandi 862600351 3 nurandi 2160025940 4 nurandi 80126180 5 nurandi 3272463157 6 nurandi 176519485 7 nurandi 1200006384 8 nurandi 775449094739197953 9 nurandi 68746721 10 nurandi 1408142352 # \u0026hellip; with 315 more rows {% endhighlight %}\nSelanjutnya, untuk mendapatkan detail dari list user ID followers/friends, kita dapat menggunakan fungsi lookup_users(). Misal:\n{% highlight r %} detail_followings \u0026lt;- lookup_users(followings$user_id) {% endhighlight %}\n{% highlight r %} detail_followings[,c(\u0026ldquo;created_at\u0026rdquo;, \u0026ldquo;screen_name\u0026rdquo;, \u0026ldquo;location\u0026rdquo;, \u0026ldquo;description\u0026rdquo;)] {% endhighlight %}\n{% highlight text %}\n# A tibble: 325 x 4 created_at screen_name location description 1 2019-01-07 20:13:53 perrystephe~ Sydney I tweet (rarely) about #r~ 2 2019-01-16 12:03:30 kitabisacom Indonesia Situs galang dana dan don~ 3 2019-01-11 20:56:56 KJRIToronto Toronto, Ka~ Akun twitter Konsulat Jen~ 4 2018-10-24 15:30:47 kitchenerma~ Kitchener, ~ 1017 Victoria St N. (519)~ 5 2019-01-16 01:23:53 imigrasi_ja~ Kota Tua, J~ \u0026ldquo;Kantor Imigrasi Kelas I ~ 6 2019-01-16 12:19:11 flerlagekr Williamspor~ Tableau Zen Master \u0026lt;U+25CF\u0026gt; Anal~ 7 2019-01-16 12:52:46 INABadminton Cipayung, J~ \u0026ldquo;Akun Twitter Resmi Humas~ 8 2019-01-15 20:20:40 goodfellow_~ San Francis~ Google Brain research sci~ 9 2019-01-16 01:42:39 fchollet Mountain Vi~ Deep learning @google. Cr~ 10 2019-01-13 22:19:13 math_rachel San Francis~ co-founder https://t.co/Z~ # \u0026hellip; with 315 more rows {% endhighlight %}\nFungsi-fungsi yang kita bahas tadi hanya sebagian dari fitur yang tersedia pada package rtweet. Juga masih banyak parameter yang bisa ditambahkan agar pencarian yang kita lakukan sesuai kebutuhan. Untuk mengetahui fungsi-fungsi tersebut secara detail termasuk parameter yang bisa digunakan, ketik ? diikuti nama fungsi. Misal ?search_tweets. Atau, bisa juga pelajari referensi pada laman rtweet.info.\nSelamat menambang data :)\n","permalink":"/blog/rtweet-crawling-data-twitter-menggunakan-r/","summary":"Sekitar empat tahun lalu, saya menulis artikel dengan judul yang hampir sama persis: twitteR: Crawling Data Twitter Menggunakan R. Pada saat itu, cara paling mudah untuk mendapatkan (crawling) data dari Twitter dengan R adalah menggunakan package twitteR. Sayangnya pada pertengahan 2016, Jeff Gentry, sang pengembang, menghentikan pengembangan dan update/maintenance terhadap package tersebut. Meskipun package twitteR masih bisa digunakan (setidaknya sampai saat ini), Mr. Jeff merekomendasikan untuk beralih menggunakan package lain yang tidak kalah kerennya, yaitu rtweet.","title":"rtweet: Crawling Data Twitter Menggunakan R"},{"content":"Beberapa waktu lalu (tepatnya tiga tahun lalu :D) saya menulis artikel tentang bagaimana memetakan twit dengan menggunakan Leaflet. Kali ini, saya akan memetakan rute lari yang direkam perangkat GPS (jam tangan ber-GPS, smartphone, dan lain-lain) dengan memanfaatkan tools yang sama, yaitu R dan dan package leaflet. Jika belum familiar dengan Leaflet, ada baiknya membaca artikel ini. Bocoran singkatnya, Leaflet adalah salah satu library JavaScript paling populer untuk membuat peta interaktif (bukan peta statis). Package leaflet dikembangkan oleh RStudio untuk memudahkan pembuatan peta melalui R, tanpa harus menulis kode JavaScript.\nData yang diperlukan Tentu saja yang paling utama adalah data tracking/rute (lari, bersepeda, dan lain-lain) dalam bentuk titik-titik koordinat (latitide-longitude). Data tersebut direkam dengan perangkat atau aplikasi GPS dan biasanya disimpan dalam format GPX (GPS exchange format), TCX (training center XML), FIT (flexible and interoperable data transfer), atau format lainnya. Contoh pada artikel ini akan menggunakan data berformat GPX. File GPX dapat diperoleh dari aplikasi sport tracking seperti Garmin Connect, Endomondo dan Strava.\nGarmin Connect (web) : klik Activities → All Activities → pilih salah satu activity → simbol gear ⚙ → Export to GPX. Endomondo (web) : klik Training → Workouts atau History → pilih salah satu workout → simbol ⋁ → Export → pilih GPX Format → Export. Strava (web) : klik Training Log atau My Activities → pilih salah satu activity → simbol three dots ⋯ → Export GPX. Tidak pernah menggunakan aplikasi tracking atau tidak punya file GPX? Silakan download punya saya di sini.\n{% include base_path %}\n{% capture fig_img %} ![Strava-map]({{ base_path }}/img/blog/2019-07-15-visualisasi-rute-lari-dengan-r-dan-leaflet/strava-map.png) {% endcapture %}\n{{ fig_img | markdownify | remove: \"\" | remove: \"\n\" }}\rPeta rute lari pada Strava beserta foto sepanjang rute yang ditampilkan dalam bentuk *pop-up*. [Klik untuk lihat detail.](https://www.strava.com/activities/2474503416)\rNice to have: Jika saat lari sempat ambil foto (menggunakan smartphone atau kamera digital dengan location-enabled), kita bisa memasangnya pada peta dalam bentuk pop-up (lihat screen-shot Strava di atas). Ini akan saya bahas pada artikel ini. Silakan ambil foto-fotonya di sini jika menggunakan file GPX saya.\nPackage(s) Ada tiga packages yang akan digunakan, yaitu:\nplotKML untuk membaca file GPX. Alternatif lain adalah package XML dan maptools. exifr untuk membaca exif (exchangeable image format) atau metadata dari image, dalam hal ini kita akan membaca titik koordinat (latitude-longitude) di mana sebuah foto diambil. leaflet untuk membuat peta. Jika package(s) tersebut belum terinstal pada R, silakan instal terlebih dahulu dengan perintah\n{% highlight r %} install.packages(c(\u0026ldquo;plotKML\u0026rdquo;, \u0026ldquo;exifr\u0026rdquo;, \u0026ldquo;leaflet\u0026rdquo;)) {% endhighlight %}\nKhusus leaflet, bisa juga instal versi development-nya dari Github. exifr berjalan dengan di atas Perl. Silakan instal salah satu aplikasi Perl agar exifr dapat berfungsi sebagaimana mestinya.\n{% highlight r %} if (!require(\u0026ldquo;devtools\u0026rdquo;)) install.packages(\u0026ldquo;devtools\u0026rdquo;) devtools::install_github(\u0026ldquo;rstudio/leaflet\u0026rdquo;) {% endhighlight %}\nSetelah itu, load semua packages.\n{% highlight r %} library(plotKML) library(exifr) library(leaflet) {% endhighlight %}\nLet\u0026rsquo;s map your running route! Data sudah tersedia. Package(s) yang diperlukan sudah terinstal. Let\u0026rsquo;s map your running route! Ada beberapa tahapan sederhana yang harus dilakukan, yaitu membaca file GPX, membaca exif dari foto, dan membuat peta.\nMembaca file GPX untuk mendapatkan titik-titik koordinat dari rute File GPX dapat dibaca menggunakan fungsi readGPX yang tersedia pada package plotKML.\n{% highlight r %} gpx_file \u0026lt;- \u0026ldquo;Light_Trail_at_Laurel_Creek.gpx\u0026rdquo; route \u0026lt;- readGPX(gpx_file) {% endhighlight %}\n{% highlight r %} str(route) {% endhighlight %}\n{% highlight text %}\nList of 5 $ metadata : NULL $ bounds : NULL $ waypoints: NULL $ tracks :List of 1 ..$ :List of 1 .. ..$ Light Trail at Laurel Creek 🏞️:\u0026lsquo;data.frame\u0026rsquo;:\t7995 obs. of 5 variables: .. .. ..$ lon : num [1:7995] -80.5 -80.5 -80.5 -80.5 -80.5 \u0026hellip; .. .. ..$ lat : num [1:7995] 43.5 43.5 43.5 43.5 43.5 \u0026hellip; .. .. ..$ ele : chr [1:7995] \u0026ldquo;335.3\u0026rdquo; \u0026ldquo;335.3\u0026rdquo; \u0026ldquo;335.2\u0026rdquo; \u0026ldquo;335.1\u0026rdquo; \u0026hellip; .. .. ..$ time : chr [1:7995] \u0026ldquo;2019-06-23T13:08:04Z\u0026rdquo; \u0026ldquo;2019-06-23T13:08:05Z\u0026rdquo; \u0026ldquo;2019-06-23T13:08:06Z\u0026rdquo; \u0026ldquo;2019-06-23T13:08:07Z\u0026rdquo; \u0026hellip; .. .. ..$ extensions: chr [1:7995] \u0026ldquo;14258\u0026rdquo; \u0026ldquo;1420\u0026rdquo; \u0026ldquo;1420\u0026rdquo; \u0026ldquo;1410\u0026rdquo; \u0026hellip; $ routes : NULL {% endhighlight %}\nObjek route merupakan list dengan lima elemen. Yang akan kita gunakan adalah elemen data-frame pada element tracks.\n{% highlight r %} route \u0026lt;- route$tracks[[1]][[1]] str(route) {% endhighlight %}\n{% highlight text %}\n\u0026lsquo;data.frame\u0026rsquo;:\t7995 obs. of 5 variables: $ lon : num -80.5 -80.5 -80.5 -80.5 -80.5 \u0026hellip; $ lat : num 43.5 43.5 43.5 43.5 43.5 \u0026hellip; $ ele : chr \u0026ldquo;335.3\u0026rdquo; \u0026ldquo;335.3\u0026rdquo; \u0026ldquo;335.2\u0026rdquo; \u0026ldquo;335.1\u0026rdquo; \u0026hellip; $ time : chr \u0026ldquo;2019-06-23T13:08:04Z\u0026rdquo; \u0026ldquo;2019-06-23T13:08:05Z\u0026rdquo; \u0026ldquo;2019-06-23T13:08:06Z\u0026rdquo; \u0026ldquo;2019-06-23T13:08:07Z\u0026rdquo; \u0026hellip; $ extensions: chr \u0026ldquo;14258\u0026rdquo; \u0026ldquo;1420\u0026rdquo; \u0026ldquo;1420\u0026rdquo; \u0026ldquo;1410\u0026rdquo; \u0026hellip; {% endhighlight %}\nSekarang objek route berupa data-frame dengan kolom-kolom: long (longitude), lat (latitude), ele (elevation), time dan extensions.\nMembaca exif dari foto untuk mendapatkan titik koordinatnya Exif atau medatada bisa dibaca dengan fungsi read_exif pada package exifr. Saya asumsikan file-file foto berapa pada folder img di working directory.\n{% highlight r %} picture_files \u0026lt;- list.files(\u0026ldquo;img\u0026rdquo;, full.names = TRUE)\npicture_point \u0026lt;- read_exif(picture_files, tags = c(\u0026ldquo;FileName\u0026rdquo;, \u0026ldquo;GPSLatitude\u0026rdquo;, \u0026ldquo;GPSLongitude\u0026rdquo;), quiet = TRUE) {% endhighlight %}\nParameter tag berguna untuk memilih tag atau informasi apa saja yang akan diambil. Jika ingin mengambil semua informasi yang tersedia, hilangkan parameter tersebut.\n{% highlight r %} str(picture_point) {% endhighlight %}\n{% highlight text %}\nClasses \u0026rsquo;tbl_df\u0026rsquo;, \u0026rsquo;tbl\u0026rsquo; and \u0026lsquo;data.frame\u0026rsquo;:\t13 obs. of 4 variables: $ SourceFile : chr \u0026ldquo;/Users/\u0026hellip;/finish.png\u0026rdquo; \u0026ldquo;/Users/\u0026hellip;/IMG_20190623_091723989_HDR~2.jpg\u0026rdquo; \u0026ldquo;/Users/\u0026hellip;/IMG_20190623_095219047_HDR~2.jpg\u0026rdquo; \u0026ldquo;/Users/\u0026hellip;/IMG_20190623_101644766~2.jpg\u0026rdquo; \u0026hellip; $ FileName : chr \u0026ldquo;finish.png\u0026rdquo; \u0026ldquo;IMG_20190623_091723989_HDR~2.jpg\u0026rdquo; \u0026ldquo;IMG_20190623_095219047_HDR~2.jpg\u0026rdquo; \u0026ldquo;IMG_20190623_101644766~2.jpg\u0026rdquo; \u0026hellip; $ GPSLatitude : num NA 43.5 43.5 43.5 43.5 \u0026hellip; $ GPSLongitude: num NA -80.6 -80.6 -80.6 -80.6 \u0026hellip; {% endhighlight %}\nBeberapa file tanpa titik koordinat (GPSLatitude dan GPSLongitude NA). Untuk memilih hanya foto-foto yang memuat informasi koordinat, jalankan perintah berikut:\n{% highlight r %} picture_point \u0026lt;- picture_point[!is.na(picture_point$GPSLatitude), ] str(picture_point) {% endhighlight %}\n{% highlight text %}\nClasses \u0026rsquo;tbl_df\u0026rsquo;, \u0026rsquo;tbl\u0026rsquo; and \u0026lsquo;data.frame\u0026rsquo;:\t10 obs. of 4 variables: $ SourceFile : chr \u0026ldquo;/Users/\u0026hellip;/IMG_20190623_091723989_HDR~2.jpg\u0026rdquo; \u0026ldquo;/Users/\u0026hellip;/IMG_20190623_095219047_HDR~2.jpg\u0026rdquo; \u0026ldquo;/Users/\u0026hellip;/IMG_20190623_101644766~2.jpg\u0026rdquo; \u0026ldquo;/Users/\u0026hellip;/IMG_20190623_102230650~2.jpg\u0026rdquo; \u0026hellip; $ FileName : chr \u0026ldquo;IMG_20190623_091723989_HDR~2.jpg\u0026rdquo; \u0026ldquo;IMG_20190623_095219047_HDR~2.jpg\u0026rdquo; \u0026ldquo;IMG_20190623_101644766~2.jpg\u0026rdquo; \u0026ldquo;IMG_20190623_102230650~2.jpg\u0026rdquo; \u0026hellip; $ GPSLatitude : num 43.5 43.5 43.5 43.5 43.5 \u0026hellip; $ GPSLongitude: num -80.6 -80.6 -80.6 -80.6 -80.6 \u0026hellip; {% endhighlight %}\nMembuat peta! Saatnye manampilkan rute lari beserta foto dalam peta menggunakan leaflet. Berikut tahapannya:\nLangkah #1. Proses membuat peta dengan leaflet diinsiasi dengan fungsi leaflet. Dengan menjalankan fungsi ini, kita sedang menyiapkan sebuah \u0026ldquo;leyer\u0026rdquo; kosong yang di atasnya akan kita \u0026ldquo;tumpuk\u0026rdquo; layer-layer, seperti peta dasar (base map), polyline, polygon, marker, dan lain-lain.\n{% highlight r %} m \u0026lt;- leaflet() {% endhighlight %}\nLangkah #2. Tambahkan peta dasar (basemap) pada layer kosong m dengan fungsi addTiles. Secara default, peta dasar yang digunakan adalah OpenStreetMap.\n{% highlight r %} m \u0026lt;- m %\u0026gt;% addTiles(layerId = \u0026ldquo;Road\u0026rdquo;, group = \u0026ldquo;Road\u0026rdquo;) {% endhighlight %}\nMeskipun opsional, sangat disarankan untuk menggunakan parameter layerId dan group. layerId berfungsi untuk menandai sebuah layer atau objek pada peta. Satu atau beberapa layer bisa dikelompokkan dalam sebuah group. Salah satu kegunaan dari layerId maupun group adalah memudahkan kita dalam modifikas sebuah layer atau grup layer. Sebagai contoh untuk menghapus layer basemap:\n{% highlight r %} m %\u0026gt;% removeTiles(\u0026ldquo;Road\u0026rdquo;) {% endhighlight %}\nOperator %\u0026gt;% diadopsi dari package magrittr, bertindak sebagai forward pipe operator.\nPerintah\n{% highlight r %} m \u0026lt;- addTiles(m) {% endhighlight %}\ndapat ditulis dengan\n{% highlight r %} m \u0026lt;- m %\u0026gt;% addTiles {% endhighlight %}\nAtau secara umum\n{% highlight r %} y \u0026lt;- h(g(f(x))) {% endhighlight %}\nsama dengan\n{% highlight r %} y \u0026lt;- x %\u0026gt;% f %\u0026gt;% g %\u0026gt;% h {% endhighlight %}\nKembali ke leaflet. Kita sudah mempunya peta dangan satu layer peta dasar dalam objek m, yang dapat ditampilkan dengan cara memanggil objek tersebut.\n{% highlight r %} m {% endhighlight %}\n{% include iframe3x1.html url=\u0026ldquo;https://rstudio-pubs-static.s3.amazonaws.com/510723_a13198697f414e4fad744ff18d5a5d67.html\u0026quot; %}\nGunakan tombol (+) dan (-) untuk zoom-in atau zoom-out peta.\nLangkah #3. Selain menggunakan OpenStreetMap, kita dapat menambahkan basemap dari provider lain dengan fungsi addProviderTiles. Misalnya:\nPeta dark-mode dari CartoDB\n{% highlight r %} m \u0026lt;- m %\u0026gt;% addProviderTiles(\u0026ldquo;CartoDB.DarkMatter\u0026rdquo;, layerId = \u0026ldquo;Road Dark\u0026rdquo;, group = \u0026ldquo;Road Dark\u0026rdquo;) {% endhighlight %}\n{% include iframe3x1.html url=\u0026ldquo;https://rstudio-pubs-static.s3.amazonaws.com/510724_26f3934f95c449318d8ab42fb4d3ccf1.html\u0026quot; %}\nAtau, citra satelit dari ESRI\n{% highlight r %} m \u0026lt;- m %\u0026gt;% addProviderTiles(\u0026ldquo;Esri.WorldImagery\u0026rdquo;, layerId = \u0026ldquo;Satellite\u0026rdquo;, group = \u0026ldquo;Satellite\u0026rdquo;) {% endhighlight %}\n{% include iframe3x1.html url=\u0026ldquo;https://rstudio-pubs-static.s3.amazonaws.com/510725_6093f96266b74541b829ef672df5cd8c.html\u0026quot; %}\nDaftar provider yang tersedia dapat dilihat di sini.\nLangkah #4. Menampilkan titik-titik koordinat rute (yang sudah kita siapkan dalam data-frame route) pada peta. Rute merupakan objek polylines, dapat ditampilkan dengan menggunakan fungsi addPolylines:\n{% highlight r %} m \u0026lt;- m %\u0026gt;% addPolylines(data=route, lng = ~lon, lat = ~lat, layerId = \u0026ldquo;Running Route\u0026rdquo;, group = \u0026ldquo;Running Route\u0026rdquo;) {% endhighlight %}\n{% include iframe.html url=\u0026ldquo;https://rstudio-pubs-static.s3.amazonaws.com/510726_f824523f38d54170bbda99318fb146c6.html\u0026quot; %}\nKita dapat memasukkan parameter tambahan untuk mengatur tampilan, misalnya untuk mengubah warna. Namun, hapus dulu layer sebelumnya!.\n{% highlight r %} m %\u0026gt;% removeShape(\u0026ldquo;Running Route\u0026rdquo;) {% endhighlight %}\n{% highlight r %} m \u0026lt;- m %\u0026gt;% addPolylines(data=route, lng = ~lon, lat = ~lat, color = \u0026ldquo;red\u0026rdquo;, opacity = 1, layerId = \u0026ldquo;Running Route\u0026rdquo;, group = \u0026ldquo;Running Route\u0026rdquo;) {% endhighlight %}\n{% include iframe.html url=\u0026ldquo;https://rstudio-pubs-static.s3.amazonaws.com/510727_aedaaad2c3794caf8cf70264a60f21a3.html\u0026quot; %}\nLangkah #5. Rute sudah tergambar dalam peta. Selanjutnya adalah membuat markers atau penanda. Kita mulai dengan markers titik start dan finish. Sebelum membuat markers, tentukan dulu titik koordinatnya.\nTitik start : baris pertama pada data-frame route {% highlight r %} start_point \u0026lt;- head(route, 1) {% endhighlight %}\nTitik finish : baris terakhir pada data-frame route {% highlight r %} finish_point \u0026lt;- tail(route, 1) {% endhighlight %}\nMenambahkan markers pada peta dapat dilakukan dengan menggunakan fungsi addMarkers.\n{% highlight r %} m \u0026lt;- m %\u0026gt;% addMarkers(data = start_point, lng=~lon, lat=~lat, popup = \u0026ldquo;Start\u0026rdquo; layerId = \u0026ldquo;start\u0026rdquo;, group = \u0026ldquo;Start/Finish\u0026rdquo;) {% endhighlight %}\n{% include iframe.html url=\u0026ldquo;https://rstudio-pubs-static.s3.amazonaws.com/511095_857484b1752b4707abefaefe0c6db128.html\u0026quot; %}\nKita juga bisa mengubah marker icon dengan icon sesuai keinginan kita, misalnya dengan gambar start.jpg.\nNote: Seluruh file gambar yang akan digunakan saya simpan di Github directory\nhttps://raw.githubusercontent.com/nurandi/nurandi.github.io/master/img/blog/2019-07-15-visualisasi-rute-lari-dengan-r-dan-leaflet Agar penulisan URL dari tiap gambar yang digunakan menjadi lebih sederhana, saya membuat fungsi img_url berikut\n{% highlight r %} img_url \u0026lt;- function(file_name){ file.path(\u0026ldquo;https://raw.githubusercontent.com/nurandi/nurandi.github.io/master/img/blog/2019-07-15-visualisasi-rute-lari-dengan-r-dan-leaflet\u0026quot;, file_name) } {% endhighlight %}\nSebelum gambar custom bisa digunakan sebagai marker icon, maka harus dibuat dulu dengan perintah makeIcon\n{% highlight r %} start_icon \u0026lt;- makeIcon( iconAnchorX = 12, iconAnchorY = 12, iconUrl = img_url(\u0026ldquo;start.png\u0026rdquo;) ) {% endhighlight %}\nBarulah kita ganti default icon dengan custom icon\n{% highlight r %} m %\u0026gt;% removeMarker(\u0026ldquo;start\u0026rdquo;) {% endhighlight %}\n{% highlight r %} m \u0026lt;- m %\u0026gt;% addMarkers(data = start_point, lng=~lon, lat=~lat, popup = \u0026ldquo;Start\u0026rdquo;, icon = start_icon, layerId = \u0026ldquo;start\u0026rdquo;, group = \u0026ldquo;Start/Finish\u0026rdquo;) {% endhighlight %}\n{% include iframe.html url=\u0026ldquo;http://rstudio-pubs-static.s3.amazonaws.com/556571_02992237a3e34f94a579f8fcdb503ee8.html\u0026quot; %}\nCara yang sama bisa kita lakukan untuk menambahkan marker titik finish\n{% highlight r %} finish_icon \u0026lt;- makeIcon( iconAnchorX = 12, iconAnchorY = 12, iconUrl = img_url(\u0026ldquo;finish.png\u0026rdquo;) )\nm \u0026lt;- m %\u0026gt;% addMarkers(data = finish_point, lng=~lon, lat=~lat, popup = \u0026ldquo;Finish\u0026rdquo;, icon = finish_icon, layerId = \u0026ldquo;finish\u0026rdquo;, group = \u0026ldquo;Start/Finish\u0026rdquo;) {% endhighlight %}\n{% include iframe.html url=\u0026ldquo;https://rstudio-pubs-static.s3.amazonaws.com/556570_6ed6450fa9a34c9c89bc731f7086e55c.html\u0026quot; %}\nLangkah #6. Membuat markers untuk foto pada titik koordinatnya. Caranya mirip dengan Langkah #5. Yang membedakan, jika sebelumnya pop up berupa teks Start dan Finish maka di sini kita gunakan HTML untuk menampilkan foto.\nBuat icon\n{% highlight r %} picture_icon \u0026lt;- makeIcon( iconAnchorX = 12, iconAnchorY = 12, iconUrl = img_url(\u0026ldquo;picture.png\u0026rdquo;) ) {% endhighlight %}\nData titik koordinat foto di simpan dalam data frame picture_point. Kita buat kolom popup berupa kode HTML untuk menampilkan foto.\n{% highlight r %} picture_point$popup \u0026lt;- paste(\u0026rsquo;\u0026rsquo;, sep=\u0026rsquo;\u0026rsquo;) {% endhighlight %}\nTampilkan markers\n{% highlight r %} m \u0026lt;- m %\u0026gt;% addMarkers(data = picture_point, lng=~GPSLongitude, lat=~GPSLatitude, popup = ~popup, icon = picture_icon, options = popupOptions(maxWidth= \u0026ldquo;auto\u0026rdquo;,keepInView = TRUE), group =\u0026lsquo;Pictures\u0026rsquo;) {% endhighlight %}\n{% include iframe.html url=\u0026ldquo;http://rstudio-pubs-static.s3.amazonaws.com/556572_15b456405a114aaead4d0e7aed54c121.html\u0026quot; %}\nJika salah satu marker kita klik, foto akan muncul pada pop up.\nLangkah #7. Atau langkah terakhir adalah membuat layer control, agar user dapat:\nmemilih basemap apa yang akan digunakan menampilkan atau menyebunyikan rute, markers start/finish, maupun markers foto. Fungsi yang digunakan adalah addLayersControl\n{% highlight r %} m \u0026lt;- m %\u0026gt;% addLayersControl(position = \u0026rsquo;topright\u0026rsquo;, baseGroups = c(\u0026ldquo;Road\u0026rdquo;, \u0026ldquo;Road Dark\u0026rdquo;, \u0026ldquo;Satellite\u0026rdquo;), overlayGroups = c(\u0026ldquo;Running Route\u0026rdquo;, \u0026ldquo;Start/Finish\u0026rdquo;, \u0026ldquo;Pictures\u0026rdquo;), options = layersControlOptions(collapsed = FALSE)) {% endhighlight %}\n{% include iframe.html url=\u0026ldquo;http://rstudio-pubs-static.s3.amazonaws.com/556573_0682aa10717340f7a09a36fa09a3da16.html\u0026quot; %}\nSelesai!\nJika digabungkan, maka inilah kode lengkap untuk menampilkan rute lari beserta foto dengan menggunakan R dan leaflet:\n{% highlight r %}\ninstall package(s) yg diperlukan install.packages(c(\u0026ldquo;plotKML\u0026rdquo;, \u0026ldquo;exifr\u0026rdquo;, \u0026ldquo;leaflet\u0026rdquo;))\nload package(s) library(plotKML) library(exifr) library(leaflet)\nmembaca rute dari file GPX gpx_file \u0026lt;- \u0026ldquo;Light_Trail_at_Laurel_Creek.gpx\u0026rdquo; route \u0026lt;- readGPX(gpx_file) route \u0026lt;- route$tracks[[1]][[1]]\ntentukan titik start/finish start_point \u0026lt;- head(route, 1) finish_point \u0026lt;- tail(route, 1)\nmembaca exif dari foto picture_files \u0026lt;- list.files(\u0026ldquo;img\u0026rdquo;, full.names = TRUE) picture_point \u0026lt;- read_exif(picture_files, tags = c(\u0026ldquo;FileName\u0026rdquo;, \u0026ldquo;GPSLatitude\u0026rdquo;, \u0026ldquo;GPSLongitude\u0026rdquo;), quiet = TRUE)\npilih foto yang mempunyai informasi koordinat picture_point \u0026lt;- picture_point[!is.na(picture_point$GPSLatitude), ]\nmembuat icon untuk titik start/finish/picture img_url \u0026lt;- function(file_name){ file.path(\u0026ldquo;https://raw.githubusercontent.com/nurandi/nurandi.github.io/master/img/blog/2019-07-15-visualisasi-rute-lari-dengan-r-dan-leaflet\u0026quot;, file_name) }\nstart_icon \u0026lt;- makeIcon( iconAnchorX = 12, iconAnchorY = 12, iconUrl = img_url(\u0026ldquo;start.png\u0026rdquo;) )\nfinish_icon \u0026lt;- makeIcon( iconAnchorX = 12, iconAnchorY = 12, iconUrl = img_url(\u0026ldquo;finish.png\u0026rdquo;) )\npicture_icon \u0026lt;- makeIcon( iconAnchorX = 12, iconAnchorY = 12, iconUrl = img_url(\u0026ldquo;picture.png\u0026rdquo;) )\nmembuat kode HTML untuk pop-up picture picture_point$popup \u0026lt;- paste(\u0026rsquo;\u0026rsquo;, sep=\u0026rsquo;\u0026rsquo;)\nMEMBUAT PETA inisiasi peta dengan leaflet m \u0026lt;- leaflet() %\u0026gt;%\n# base map default\raddTiles(layerId = \u0026quot;Road\u0026quot;,\rgroup = \u0026quot;Road\u0026quot;) %\u0026gt;%\r# base map CartoDB\raddProviderTiles(\u0026quot;CartoDB.DarkMatter\u0026quot;, layerId = \u0026quot;Road Dark\u0026quot;,\rgroup = \u0026quot;Road Dark\u0026quot;) %\u0026gt;%\r# basemap satellite\raddProviderTiles(\u0026quot;Esri.WorldImagery\u0026quot;, layerId = \u0026quot;Satellite\u0026quot;,\rgroup = \u0026quot;Satellite\u0026quot;) %\u0026gt;%\r# route\raddPolylines(data=route, lng = ~lon, lat = ~lat, color = \u0026quot;red\u0026quot;, opacity = 1,\rlayerId = \u0026quot;Running Route\u0026quot;,\rgroup = \u0026quot;Running Route\u0026quot;) %\u0026gt;%\r# start marker\raddMarkers(data = start_point, lng=~lon, lat=~lat,\rpopup = \u0026quot;Start\u0026quot;,\ricon = start_icon,\rlayerId = \u0026quot;start\u0026quot;,\rgroup = \u0026quot;Start/Finish\u0026quot;) %\u0026gt;%\r# finish marker\raddMarkers(data = finish_point, lng=~lon, lat=~lat,\rpopup = \u0026quot;Finish\u0026quot;,\ricon = finish_icon,\rlayerId = \u0026quot;finish\u0026quot;,\rgroup = \u0026quot;Start/Finish\u0026quot;) %\u0026gt;%\r# picture marker dan pop-up\raddMarkers(data = picture_point, lng=~GPSLongitude, lat=~GPSLatitude,\rpopup = ~popup,\ricon = picture_icon,\roptions = popupOptions(maxWidth= \u0026quot;auto\u0026quot;,keepInView = TRUE),\rgroup ='Pictures') %\u0026gt;%\r# layer control\raddLayersControl(position = 'topright',\rbaseGroups = c(\u0026quot;Road\u0026quot;, \u0026quot;Road Dark\u0026quot;, \u0026quot;Satellite\u0026quot;),\roverlayGroups = c(\u0026quot;Running Route\u0026quot;, \u0026quot;Start/Finish\u0026quot;, \u0026quot;Pictures\u0026quot;),\roptions = layersControlOptions(collapsed = FALSE)) selesai m {% endhighlight %}\nSelamat mencoba. Semoga bermanfaat :)\n","permalink":"/blog/visualisasi-rute-lari-dengan-r-dan-leaflet/","summary":"Beberapa waktu lalu (tepatnya tiga tahun lalu :D) saya menulis artikel tentang bagaimana memetakan twit dengan menggunakan Leaflet. Kali ini, saya akan memetakan rute lari yang direkam perangkat GPS (jam tangan ber-GPS, smartphone, dan lain-lain) dengan memanfaatkan tools yang sama, yaitu R dan dan package leaflet. Jika belum familiar dengan Leaflet, ada baiknya membaca artikel ini. Bocoran singkatnya, Leaflet adalah salah satu library JavaScript paling populer untuk membuat peta interaktif (bukan peta statis).","title":"Visualisasi Rute Lari dengan R dan Leaflet"},{"content":"Di era digital sekarang ini, berbagai data dapat ditemukan dengan mudah di internet. Sebagai seorang data analis dan scientist, hal ini tentu menjadi kabar baik karena dapat meningkatkan kualitas model dan mempertajam hasil analisis. Tapi bagaimana jika data tersebut tersedia dalam website yang diperuntukan untuk dibaca melalui browser? Beberapa website memang menyediakan fasilitas untuk menyimpan data (seperti Twitter melalui API public), tapi sayangnya sebagian besar tidak. Salah satu cara yang umum dilakukan adalah dengan membuka satu-per-satu halaman web lalu \u0026ldquo;copy-paste\u0026rdquo; data secara manual - tentunya akan menyita banyak waktu jika data sangat banyak. Web scraping adalah teknik yang lebih \u0026ldquo;smart\u0026rdquo; untuk otomatisasi proses copy-paste ini. Selain agar lebih efisien, tujuan utama dari web scraping sebenarnya adalah memanfaatkan struktur atau pola dari suatu laman web untuk mengekstrak dan menyimpan data dalam format yang diinginkan untuk dianalisis lebih lanjut.\nSecara teknis, ada beberapa pendekatan untuk melakukan web scraping, diantaranya:\nParsing HTML dari suatu laman web menggunakan CSS selector. Merupakan cara yang umum digunakan dan biasanya dapat dilakukan untuk banyak website. Schema JSON linked data dan JavaScript variable. XHR (XML HTTP Requests) Melalui artikel ini mari kita pelajari yang pertama: scraping dengan cara parsing HTML dari suatu laman HTML. Tools yang akan digunakan adalah R dengan package rvest. Agar lebih menarik, saya menggunakan contoh real berupa data top-scorers Liga Inggris dari halaman BBC Sport.\n{% include base_path %} {% capture fig_img %} ![BBC EPL Top Scorers]({{ base_path }}/img/blog/2019-11-05-web-scraping-dengan-r-dan-rvest/bbc-epl-top-scorers.png) {% endcapture %}\n{{ fig_img | markdownify | remove: \"\" | remove: \"\n\" }}\rTop Scorers Liga Inggris. Diakses dari [BBC Sport](https://www.bbc.com/sport/football/premier-league/top-scorers) pada 5 November 2019\rCatatan: Web scraping merupakan salah satu teknik yang sangat bermanfaat untuk mendapatkan data dari internet, tetapi dapat menyebabkan masalah bagi beberapa website. Untuk itu, proses web scraping harus dilakukan dengan penuh pertimbangan dan etika. Sebelum melakukan web scraping sebaiknya periksa dulu apakah website mempunyai file robots.txt? Jika iya, lihat apakah diizinkan untuk melakukan scraping pada halaman yang kita inginkan. File robots.txt dapat diakses di nama-domain/robots.txt, misalnya https://www.bbc.com/robots.txt.\nPackage rvest Package rvest ditulis oleh Hadley Wickham dari RStudio. Package ini mempunyai fungsi yang serupa dengan library beautiful soup pada Python, yaitu untuk web scraping. Langkah pertama, tentu saja, install dan load package rvest.\n{% highlight r %} install.packages(\u0026ldquo;rvest\u0026rdquo;) library(rvest) {% endhighlight %}\nInspect and scrape Proses scraping kita mulai dengan membaca file HTML dari halaman website dengan menggunakan fungsi read_html.\n{% highlight r %} url \u0026lt;- \u0026ldquo;https://www.bbc.com/sport/football/premier-league/top-scorers\u0026quot; html \u0026lt;- read_html(url) {% endhighlight %}\nSelanjutnya, melalui browser kita identifikasi \u0026ldquo;letak\u0026rdquo; dari data yang akan kita ekstrak. Pada contoh ini, kita akan ekstrak list top scorers termasuk detailnya meliputi:\nplayer name team total goal scored minutes played minutes per goal total assists total shots on goal target total shots percentage on target Caranya, buka URL top-scorers melalui browser (misal pada contoh ini saya menggunakan Google Chrome). Klik kanan, klik Inspect lalu klik tab Element. Klik icon tanda panah di bagian kiri-atas, lalu arahkan kursor pada teks/element yang akan kita ekstrak. Sebagai contoh untuk mengekstrak nama pemain, bisa arahkan kursor pada salah satu nama pemain.\n{% capture fig_img %} ![Inspect element]({{ base_path }}/img/blog/2019-11-05-web-scraping-dengan-r-dan-rvest/inspect-element.png) {% endcapture %}\n{{ fig_img | markdownify | remove: \"\" | remove: \"\n\" }}\rInspect element pada Google Chrome. Dapat ditampilkan dengan cara klik kanan lalu klik *Inspect*\rSecara otomatis Chrome akan meng-highlight baris element HTML di mana teks itu berada, yaitu:\n\u0026lt;h2 class=\u0026#34;top-player-stats__name gel-double-pica\u0026#34;\u0026gt;Sadio Mané\u0026lt;/h2\u0026gt; Yang kita perlukan adalah CSS selectors atau XPath dari element tersebut. CSS selector biasanya ditandai dengan class, id, dan sebagainya (referensi). CSS selector untuk nama pemain adalah top-player-stats__name. Karena merupakan class, tambahkan titik sebelum huruf pertama, sehingga menjadi .top-player-stats__name.\nKembali ke R. Setelah mengetahui selector-nya, kita bisa mengekstrak informasi nama pemain dengan fungsi html_nodes (jika hanya satu pemain saja bisa menggunakan html_node) dan html_text untuk mengambil teksnya. Parameter trim = TRUE berguna untuk menghilangkan space sebelum/setelah teks.\n{% highlight r %} html %\u0026gt;% html_nodes(\u0026quot;.top-player-stats__name\u0026rdquo;) %\u0026gt;% html_text(trim = TRUE) {% endhighlight %}\nDengan cara seperti di atas, kita bisa mengekstrak nama team dengan selector .top-player-stats__team\n{% highlight r %} html %\u0026gt;% html_nodes(\u0026quot;.top-player-stats__team\u0026quot;) %\u0026gt;% html_text(trim = TRUE) {% endhighlight %}\nMembuat fungsi scraping Karena proses ekstraksi data merupakan pengulangan (dengan mengganti CSS selector), sangat disarankan untuk dibuat sebagai fungsi.\n{% highlight r %} scrape \u0026lt;- function(selector, html){ html %\u0026gt;% html_nodes(selector) %\u0026gt;% html_text(trim = TRUE) } {% endhighlight %}\nSehingga untuk mendapatkan total goals scored cukup dengan perintah\n{% highlight r %} scrape(\u0026quot;.top-player-stats__goals-scored-number\u0026quot;, html) {% endhighlight %}\nSelanjutnya kita iterasi fungsi scrape untuk seluruh selector. Iterasi bisa menggunakan fungsi sapply/lapply.\n{% highlight r %} selector \u0026lt;- c(\u0026quot;.top-player-stats__name\u0026quot;, \u0026ldquo;.top-player-stats__team\u0026rdquo;, \u0026ldquo;.top-player-stats__goals-scored-number\u0026rdquo;, \u0026ldquo;.top-player-stats__mins-played\u0026rdquo;, \u0026ldquo;.top-player-stats__mins-per-goal\u0026rdquo;, \u0026ldquo;.top-player-stats__assists\u0026rdquo;, \u0026ldquo;.shots-on-goal-total\u0026rdquo;, \u0026ldquo;.shots-total\u0026rdquo;, \u0026ldquo;.percentage-goals-on-target\u0026rdquo;)\ntop_scorers \u0026lt;- sapply(selector, scrape, html) str(top_scorers) {% endhighlight %}\nClean up! Proses scraping sudah selesai dan hasilnya disimpan dalam matriks top-scorers. Matriks tersebut dapat kita ubah menjadi data frame dan beri nama yang tepat untuk setiap kolom.\n{% highlight r %} top_scorers \u0026lt;- as.data.frame(top_scorers)\ncol_names \u0026lt;- c(\u0026ldquo;name\u0026rdquo;, \u0026ldquo;team\u0026rdquo;, \u0026ldquo;total_goal\u0026rdquo;, \u0026ldquo;mins_played\u0026rdquo;, \u0026ldquo;mins_per_goal\u0026rdquo;, \u0026ldquo;assists\u0026rdquo;, \u0026ldquo;shots_on_goal\u0026rdquo;, \u0026ldquo;shots_total\u0026rdquo;, \u0026ldquo;percent_on_target\u0026rdquo;)\nnames(top_scorers) \u0026lt;- col_names top_scorers {% endhighlight %}\nLast but not least\u0026hellip; Tutorial ini hanya menggunakan tiga fungsi rvest. Tentu saja, ada fungsi-fungsi lain yang bisa digunakan sesuai keperluan, di antaranya:\nhtml_attr dan html_httrs : untuk ekstrak atribut, teks dan tag html_table : untuk parsing tabel HTML menjadi data frame html_form : parsing form Dan lain-lain. Sebagai catatan tambahan terkait dengan web scraping:\nScraping dengan rvest hanya bisa digunakan untuk web statis (artinya konten/data yang akan diekstrak berada dalam file HTML). Untuk web dinamis di mana data di-generate oleh JavaScript, misalnya, tidak cukup menggunakan rvest. Scraping hanya efektif apabila HTML terstruktur dengan baik. Bisa dibayangkan jika nama-nama pemain pada contoh di atas berada pada class yang berbeda? Jika tersedia, gunakan API (applicaton program interface) dan hindari scraping. Seperti telah saya sampaikan sebelumnya, lakukan scraping dengan penuh \u0026ldquo;etika\u0026rdquo;. Jangan sampai membebani website. Selamat menambang data! Semoga bermanfaat.\nPendekatan scraping lainnya akan kita pelajari pada artikel terpisah.\n","permalink":"/blog/web-scraping-dengan-r-dan-rvest/","summary":"Di era digital sekarang ini, berbagai data dapat ditemukan dengan mudah di internet. Sebagai seorang data analis dan scientist, hal ini tentu menjadi kabar baik karena dapat meningkatkan kualitas model dan mempertajam hasil analisis. Tapi bagaimana jika data tersebut tersedia dalam website yang diperuntukan untuk dibaca melalui browser? Beberapa website memang menyediakan fasilitas untuk menyimpan data (seperti Twitter melalui API public), tapi sayangnya sebagian besar tidak. Salah satu cara yang umum dilakukan adalah dengan membuka satu-per-satu halaman web lalu \u0026ldquo;copy-paste\u0026rdquo; data secara manual - tentunya akan menyita banyak waktu jika data sangat banyak.","title":"Web Scraping dengan R dan rvest"},{"content":"{% include base_path %} Artikel ini merupakan lanjutan dari artikel sebelumnya berjudul [Web Scraping dengan R dan rvest]({{ base_path }}/blog/web-scraping-dengan-r-dan-rvest/). Silakan membaca artikel tersebut terlebih dahulu jika baru memulai mempelajari web scraping dengan rvest.\nSalah satu favorit saya dalam package rvest adalah fungsi html_table. Sesuai dengan namanya, html_table berfungsi untuk parsing tabel HTML. Maksudnya, jika data yang akan di-scrape merupakan tabel dalam suatu halaman website HTML, fungsi ini secara \u0026ldquo;ajaib\u0026rdquo; akan mengubah tabel tersebut menjadi data frame. Keren bukan? Mari kita buktikan dengan scraping tabel klasemen Liga Inggris dari halaman BBC Sport.\n{% include base_path %} {% capture fig_img %} ![BBC EPL Top Scorers]({{ base_path }}/img/blog/2019-11-06-web-scraping-dengan-r-dan-rvest-parsing-tabel-html/bbc-epl-table.png) {% endcapture %}\n{{ fig_img | markdownify | remove: \"\" | remove: \"\n\" }}\rKlasemen Liga Inggris. Diakses dari [BBC Sport](https://www.bbc.com/sport/football/premier-league/table) pada 5 November 2019. Semoga sampai akhir musim urutannya tidak berubah. YNWA!\rKita mulai dengan load rvest dan baca HTML.\n{% highlight r %} library(rvest)\nurl \u0026lt;- \u0026ldquo;https://www.bbc.com/sport/football/premier-league/table\u0026quot; html \u0026lt;- url %\u0026gt;% read_html {% endhighlight %}\nMelalui Inspect elements (dijelaskan pada artikel [sebelumnya]({{ base_path }}/blog/web-scraping-dengan-r-dan-rvest/)), kita mengetahui bahwa CSS selector yang memuat tabel klasemen adalah .gs-o-table.\n\u0026lt;table class=\u0026#34;gs-o-table \u0026#34; data-reactid=\u0026#34;.98jiqbvx9q.2.0.0.0.0.1.$competition-table-0\u0026#34;\u0026gt; Dengan hanya menggunakan fungsi html_node dan html_table, kita peroleh sebuah data frame tanpa perlu repot melakukan parsing.\n{% highlight r %} epl_table \u0026lt;- html %\u0026gt;% html_node(\u0026quot;.gs-o-table\u0026rdquo;) %\u0026gt;% html_table\nstr(epl_table) {% endhighlight %}\n{% highlight text %}\n\u0026lsquo;data.frame\u0026rsquo;:\t21 obs. of 12 variables: $ : chr \u0026ldquo;1\u0026rdquo; \u0026ldquo;2\u0026rdquo; \u0026ldquo;3\u0026rdquo; \u0026ldquo;4\u0026rdquo; \u0026hellip; $ : chr \u0026ldquo;team hasn\u0026rsquo;t moved\u0026rdquo; \u0026ldquo;team hasn\u0026rsquo;t moved\u0026rdquo; \u0026ldquo;team hasn\u0026rsquo;t moved\u0026rdquo; \u0026ldquo;team hasn\u0026rsquo;t moved\u0026rdquo; \u0026hellip; $ Team: chr \u0026ldquo;Liverpool\u0026rdquo; \u0026ldquo;Man City\u0026rdquo; \u0026ldquo;Leicester\u0026rdquo; \u0026ldquo;Chelsea\u0026rdquo; \u0026hellip; $ P : chr \u0026ldquo;11\u0026rdquo; \u0026ldquo;11\u0026rdquo; \u0026ldquo;11\u0026rdquo; \u0026ldquo;11\u0026rdquo; \u0026hellip; $ W : chr \u0026ldquo;10\u0026rdquo; \u0026ldquo;8\u0026rdquo; \u0026ldquo;7\u0026rdquo; \u0026ldquo;7\u0026rdquo; \u0026hellip; $ D : chr \u0026ldquo;1\u0026rdquo; \u0026ldquo;1\u0026rdquo; \u0026ldquo;2\u0026rdquo; \u0026ldquo;2\u0026rdquo; \u0026hellip; $ L : chr \u0026ldquo;0\u0026rdquo; \u0026ldquo;2\u0026rdquo; \u0026ldquo;2\u0026rdquo; \u0026ldquo;2\u0026rdquo; \u0026hellip; $ F : chr \u0026ldquo;25\u0026rdquo; \u0026ldquo;34\u0026rdquo; \u0026ldquo;27\u0026rdquo; \u0026ldquo;25\u0026rdquo; \u0026hellip; $ A : chr \u0026ldquo;9\u0026rdquo; \u0026ldquo;10\u0026rdquo; \u0026ldquo;8\u0026rdquo; \u0026ldquo;17\u0026rdquo; \u0026hellip; $ GD : chr \u0026ldquo;16\u0026rdquo; \u0026ldquo;24\u0026rdquo; \u0026ldquo;19\u0026rdquo; \u0026ldquo;8\u0026rdquo; \u0026hellip; $ Pts : chr \u0026ldquo;31\u0026rdquo; \u0026ldquo;25\u0026rdquo; \u0026ldquo;23\u0026rdquo; \u0026ldquo;23\u0026rdquo; \u0026hellip; $ Form: chr \u0026ldquo;WWon 1 - 0 against Sheffield United on September 28th 2019.WWon 2 - 1 against Leicester City on October 5th 201\u0026rdquo;| truncated \u0026ldquo;WWon 3 - 1 against Everton on September 28th 2019.LLost 0 - 2 against Wolverhampton Wanderers on October 6th 20\u0026rdquo;| truncated \u0026ldquo;WWon 5 - 0 against Newcastle United on September 29th 2019.LLost 1 - 2 against Liverpool on October 5th 2019.WW\u0026rdquo;| truncated \u0026ldquo;WWon 2 - 0 against Brighton \u0026amp; Hove Albion on September 28th 2019.WWon 4 - 1 against Southampton on October 6th \u0026ldquo;| truncated \u0026hellip; {% endhighlight %}\nScraping dan parsing tabel HTML 100% selesai. Tinggal sedikit final-touches untuk \u0026ldquo;membersihkan\u0026rdquo; data. Pertama, hapus kolom dan baris yang tidak perlu. Jika diperhatikan (silakan print data frame), dua kolom pertama serta satu baris terakhir tidak diperlukan dan dapat dihapus.\nHapus dua kolom pertama:\n{% highlight r %} epl_table[1:2] \u0026lt;- list(NULL) {% endhighlight %}\nHapus satu baris terakhir (baris ke-21):\n{% highlight r %} epl_table \u0026lt;- epl_table[-21,] {% endhighlight %}\n{% highlight r %} str(epl_table) {% endhighlight %}\n{% highlight text %}\n\u0026lsquo;data.frame\u0026rsquo;:\t20 obs. of 10 variables: $ Team: chr \u0026ldquo;Liverpool\u0026rdquo; \u0026ldquo;Man City\u0026rdquo; \u0026ldquo;Leicester\u0026rdquo; \u0026ldquo;Chelsea\u0026rdquo; \u0026hellip; $ P : chr \u0026ldquo;11\u0026rdquo; \u0026ldquo;11\u0026rdquo; \u0026ldquo;11\u0026rdquo; \u0026ldquo;11\u0026rdquo; \u0026hellip; $ W : chr \u0026ldquo;10\u0026rdquo; \u0026ldquo;8\u0026rdquo; \u0026ldquo;7\u0026rdquo; \u0026ldquo;7\u0026rdquo; \u0026hellip; $ D : chr \u0026ldquo;1\u0026rdquo; \u0026ldquo;1\u0026rdquo; \u0026ldquo;2\u0026rdquo; \u0026ldquo;2\u0026rdquo; \u0026hellip; $ L : chr \u0026ldquo;0\u0026rdquo; \u0026ldquo;2\u0026rdquo; \u0026ldquo;2\u0026rdquo; \u0026ldquo;2\u0026rdquo; \u0026hellip; $ F : chr \u0026ldquo;25\u0026rdquo; \u0026ldquo;34\u0026rdquo; \u0026ldquo;27\u0026rdquo; \u0026ldquo;25\u0026rdquo; \u0026hellip; $ A : chr \u0026ldquo;9\u0026rdquo; \u0026ldquo;10\u0026rdquo; \u0026ldquo;8\u0026rdquo; \u0026ldquo;17\u0026rdquo; \u0026hellip; $ GD : chr \u0026ldquo;16\u0026rdquo; \u0026ldquo;24\u0026rdquo; \u0026ldquo;19\u0026rdquo; \u0026ldquo;8\u0026rdquo; \u0026hellip; $ Pts : chr \u0026ldquo;31\u0026rdquo; \u0026ldquo;25\u0026rdquo; \u0026ldquo;23\u0026rdquo; \u0026ldquo;23\u0026rdquo; \u0026hellip; $ Form: chr \u0026ldquo;WWon 1 - 0 against Sheffield United on September 28th 2019.WWon 2 - 1 against Leicester City on October 5th 201\u0026rdquo;| truncated \u0026ldquo;WWon 3 - 1 against Everton on September 28th 2019.LLost 0 - 2 against Wolverhampton Wanderers on October 6th 20\u0026rdquo;| truncated \u0026ldquo;WWon 5 - 0 against Newcastle United on September 29th 2019.LLost 1 - 2 against Liverpool on October 5th 2019.WW\u0026rdquo;| truncated \u0026ldquo;WWon 2 - 0 against Brighton \u0026amp; Hove Albion on September 28th 2019.WWon 4 - 1 against Southampton on October 6th \u0026ldquo;| truncated \u0026hellip; {% endhighlight %}\nKedua, reformat kolom Form. Kita lihat, pada kolom Form, selain singkatan dan status juga ditulis pertandingan, skor dan tanggalnya. Seperti:\n{% highlight r %} epl_table$Form[1] {% endhighlight %}\n{% highlight text %}\n[1] \u0026ldquo;WWon 1 - 0 against Sheffield United on September 28th 2019.WWon 2 - 1 against Leicester City on October 5th 2019.DDrew 1 - 1 against Manchester United on October 20th 2019.WWon 2 - 1 against Tottenham Hotspur on October 27th 2019.WWon 2 - 1 against Aston Villa on November 2nd 2019.\u0026rdquo; {% endhighlight %}\nakan kita ubah menjadi W,W,D,W,W.\nUntuk keperluan ini, kita akan menggunakan beberapa fungsi dari package stringr yang juga dikembangkan oleh tim RStudio. Silakan instal dan load package stringr:\n{% highlight r %} install.packages(\u0026ldquo;stringr\u0026rdquo;) library(stringr) {% endhighlight %}\nPertama-tama, kita ekstrak teks WWon, DDrew, atau LLost. Gunakan fungsi str_extract_all, dengan regular expression \u0026quot;WWon|DDrew|LLost\u0026quot;. Simbol | berarti \u0026ldquo;atau\u0026rdquo;.\n{% highlight r %} extract_form \u0026lt;- function(form){ str_extract_all(form, \u0026ldquo;WWon|DDrew|LLost\u0026rdquo;) }\nform \u0026lt;- sapply(epl_table$Form, extract_form, USE.NAMES = FALSE) {% endhighlight %}\n{% highlight r %} str(form) {% endhighlight %}\n{% highlight text %}\nList of 20 $ : chr [1:5] \u0026ldquo;WWon\u0026rdquo; \u0026ldquo;WWon\u0026rdquo; \u0026ldquo;DDrew\u0026rdquo; \u0026ldquo;WWon\u0026rdquo; \u0026hellip; $ : chr [1:5] \u0026ldquo;WWon\u0026rdquo; \u0026ldquo;LLost\u0026rdquo; \u0026ldquo;WWon\u0026rdquo; \u0026ldquo;WWon\u0026rdquo; \u0026hellip; $ : chr [1:5] \u0026ldquo;WWon\u0026rdquo; \u0026ldquo;LLost\u0026rdquo; \u0026ldquo;WWon\u0026rdquo; \u0026ldquo;WWon\u0026rdquo; \u0026hellip; $ : chr [1:5] \u0026ldquo;WWon\u0026rdquo; \u0026ldquo;WWon\u0026rdquo; \u0026ldquo;WWon\u0026rdquo; \u0026ldquo;WWon\u0026rdquo; \u0026hellip; $ : chr [1:5] \u0026ldquo;DDrew\u0026rdquo; \u0026ldquo;WWon\u0026rdquo; \u0026ldquo;LLost\u0026rdquo; \u0026ldquo;DDrew\u0026rdquo; \u0026hellip; $ : chr [1:5] \u0026ldquo;LLost\u0026rdquo; \u0026ldquo;DDrew\u0026rdquo; \u0026ldquo;WWon\u0026rdquo; \u0026ldquo;DDrew\u0026rdquo; \u0026hellip; $ : chr [1:5] \u0026ldquo;DDrew\u0026rdquo; \u0026ldquo;LLost\u0026rdquo; \u0026ldquo;DDrew\u0026rdquo; \u0026ldquo;DDrew\u0026rdquo; \u0026hellip; $ : chr [1:5] \u0026ldquo;LLost\u0026rdquo; \u0026ldquo;WWon\u0026rdquo; \u0026ldquo;LLost\u0026rdquo; \u0026ldquo;WWon\u0026rdquo; \u0026hellip; $ : chr [1:5] \u0026ldquo;WWon\u0026rdquo; \u0026ldquo;WWon\u0026rdquo; \u0026ldquo;LLost\u0026rdquo; \u0026ldquo;DDrew\u0026rdquo; \u0026hellip; $ : chr [1:5] \u0026ldquo;DDrew\u0026rdquo; \u0026ldquo;LLost\u0026rdquo; \u0026ldquo;DDrew\u0026rdquo; \u0026ldquo;WWon\u0026rdquo; \u0026hellip; $ : chr [1:5] \u0026ldquo;WWon\u0026rdquo; \u0026ldquo;LLost\u0026rdquo; \u0026ldquo;DDrew\u0026rdquo; \u0026ldquo;LLost\u0026rdquo; \u0026hellip; $ : chr [1:5] \u0026ldquo;WWon\u0026rdquo; \u0026ldquo;WWon\u0026rdquo; \u0026ldquo;DDrew\u0026rdquo; \u0026ldquo;DDrew\u0026rdquo; \u0026hellip; $ : chr [1:5] \u0026ldquo;DDrew\u0026rdquo; \u0026ldquo;LLost\u0026rdquo; \u0026ldquo;LLost\u0026rdquo; \u0026ldquo;DDrew\u0026rdquo; \u0026hellip; $ : chr [1:5] \u0026ldquo;DDrew\u0026rdquo; \u0026ldquo;WWon\u0026rdquo; \u0026ldquo;LLost\u0026rdquo; \u0026ldquo;LLost\u0026rdquo; \u0026hellip; $ : chr [1:5] \u0026ldquo;LLost\u0026rdquo; \u0026ldquo;WWon\u0026rdquo; \u0026ldquo;LLost\u0026rdquo; \u0026ldquo;DDrew\u0026rdquo; \u0026hellip; $ : chr [1:5] \u0026ldquo;DDrew\u0026rdquo; \u0026ldquo;WWon\u0026rdquo; \u0026ldquo;WWon\u0026rdquo; \u0026ldquo;LLost\u0026rdquo; \u0026hellip; $ : chr [1:5] \u0026ldquo;LLost\u0026rdquo; \u0026ldquo;LLost\u0026rdquo; \u0026ldquo;WWon\u0026rdquo; \u0026ldquo;LLost\u0026rdquo; \u0026hellip; $ : chr [1:5] \u0026ldquo;LLost\u0026rdquo; \u0026ldquo;LLost\u0026rdquo; \u0026ldquo;DDrew\u0026rdquo; \u0026ldquo;LLost\u0026rdquo; \u0026hellip; $ : chr [1:5] \u0026ldquo;LLost\u0026rdquo; \u0026ldquo;LLost\u0026rdquo; \u0026ldquo;DDrew\u0026rdquo; \u0026ldquo;LLost\u0026rdquo; \u0026hellip; $ : chr [1:5] \u0026ldquo;LLost\u0026rdquo; \u0026ldquo;DDrew\u0026rdquo; \u0026ldquo;DDrew\u0026rdquo; \u0026ldquo;DDrew\u0026rdquo; \u0026hellip; {% endhighlight %}\nSelanjutnya dalam setiap elemen list, ekstrak satu huruf W, D, atau L lalu gabungkan dengan delimiter tanda koma. Ekstraksi huruf menggunakan fungsi str_extract.\n{% highlight r %} simply_form \u0026lt;- function(form){ form %\u0026gt;% str_extract(\u0026ldquo;W|D|L\u0026rdquo;) %\u0026gt;% paste(collapse = \u0026ldquo;,\u0026rdquo;) }\nform \u0026lt;- sapply(form, simply_form) {% endhighlight %}\n{% highlight r %} str(form) {% endhighlight %}\n{% highlight text %}\nchr [1:20] \u0026ldquo;W,W,D,W,W\u0026rdquo; \u0026ldquo;W,L,W,W,W\u0026rdquo; \u0026ldquo;W,L,W,W,W\u0026rdquo; \u0026ldquo;W,W,W,W,W\u0026rdquo; \u0026hellip; {% endhighlight %}\nTerakhir, update kolom Form pada data frame epl_table dengan vector form.\n{% highlight r %} epl_table$Form \u0026lt;- form {% endhighlight %}\nDan\u0026hellip; ini hasil akhirnya\n{% highlight r %} print(epl_table) {% endhighlight %}\n{% highlight text %}\nTeam P W D L F A GD Pts Form 1 Liverpool 11 10 1 0 25 9 16 31 W,W,D,W,W 2 Man City 11 8 1 2 34 10 24 25 W,L,W,W,W 3 Leicester 11 7 2 2 27 8 19 23 W,L,W,W,W 4 Chelsea 11 7 2 2 25 17 8 23 W,W,W,W,W 5 Arsenal 11 4 5 2 16 15 1 17 D,W,L,D,D 6 Sheff Utd 11 4 4 3 12 8 4 16 L,D,W,D,W 7 Bournemouth 11 4 4 3 14 13 1 16 D,L,D,D,W 8 Brighton 11 4 3 4 14 14 0 15 L,W,L,W,W 9 Crystal Palace 11 4 3 4 10 14 -4 15 W,W,L,D,L 10 Man Utd 11 3 4 4 13 11 2 13 D,L,D,W,L 11 Tottenham 11 3 4 4 17 16 1 13 W,L,D,L,D 12 Wolves 11 2 7 2 14 14 0 13 W,W,D,D,D 13 West Ham 11 3 4 4 14 17 -3 13 D,L,L,D,L 14 Burnley 11 3 3 5 14 18 -4 12 D,W,L,L,L 15 Newcastle 11 3 3 5 9 17 -8 12 L,W,L,D,W 16 Aston Villa 11 3 2 6 16 18 -2 11 D,W,W,L,L 17 Everton 11 3 2 6 11 17 -6 11 L,L,W,L,D 18 Southampton 11 2 2 7 10 27 -17 8 L,L,D,L,L 19 Norwich 11 2 1 8 11 26 -15 7 L,L,D,L,L 20 Watford 11 0 5 6 6 23 -17 5 L,D,D,D,L {% endhighlight %}\nAjaib bukan? Selamat mencoba!\n","permalink":"/blog/web-scraping-dengan-r-dan-rvest-parsing-tabel-html/","summary":"{% include base_path %} Artikel ini merupakan lanjutan dari artikel sebelumnya berjudul [Web Scraping dengan R dan rvest]({{ base_path }}/blog/web-scraping-dengan-r-dan-rvest/). Silakan membaca artikel tersebut terlebih dahulu jika baru memulai mempelajari web scraping dengan rvest.\nSalah satu favorit saya dalam package rvest adalah fungsi html_table. Sesuai dengan namanya, html_table berfungsi untuk parsing tabel HTML. Maksudnya, jika data yang akan di-scrape merupakan tabel dalam suatu halaman website HTML, fungsi ini secara \u0026ldquo;ajaib\u0026rdquo; akan mengubah tabel tersebut menjadi data frame.","title":"Web Scraping dengan R dan rvest: Parsing Tabel HTML"}]